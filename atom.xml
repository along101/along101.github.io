<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>along101 个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/along101/"/>
  <updated>2018-07-13T07:39:30.296Z</updated>
  <id>https://github.com/along101/</id>
  
  <author>
    <name>along101</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-cloud-openfeign 深度分析</title>
    <link href="https://github.com/along101/2018/06/15/spring-cloud-openfeign/"/>
    <id>https://github.com/along101/2018/06/15/spring-cloud-openfeign/</id>
    <published>2018-06-15T04:03:13.000Z</published>
    <updated>2018-07-13T07:39:30.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/OpenFeign/feign">feign</a>是一个声明试的HTTP客户端，spring-cloud-openfeign将feign集成到spring boot中，在接口上通过注解声明Rest协议，将http调用转换为接口方法的调用，使得客户端调用http服务更加简单。</p><p>当前spring cloud最新稳定版本是Edgware，feign在其集成的<a href="https://github.com/spring-cloud/spring-cloud-netflix">spring-cloud-netflix</a> 1.4.0.RELEASE版本中。</p><blockquote><p>spring cloud下一个版本是Finchley，将会单独集成<a href="https://github.com/spring-cloud/spring-cloud-openfeign">spring-cloud-openfeign</a></p></blockquote><a id="more"></a><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>我们来看个简单的例子。源代码链接：<a href="https://github.com/along101/spring-boot-test/tree/master/feign-test">https://github.com/along101/spring-boot-test/tree/master/feign-test</a></p><h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><p>使用spring boot编写一个简单的Rest服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello1"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码很简单，通过springMVC注解在接口HelloService上声明Rest服务，HelloController被@RestController注解声明为一个Rest服务。</p><p>启动spring boot 就可通过浏览器访问<a href="http://localhost:8080/test/hello1?name=ppdai得到返回Hello" target="_blank" rel="noopener">http://localhost:8080/test/hello1?name=ppdai得到返回Hello</a> ppdai。</p><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><p>客户端pom中需要加入spring-cloud-starter-feign的依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>Camden.SR7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在客户端中新建一个HelloClient接口继承服务端HelloService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在spring boot配置文件中配置remote.hello.service.host=http://localhost:8080</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"HELLO-SERVICE"</span>, url = <span class="string">"$&#123;remote.hello.service.host&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> <span class="keyword">extends</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloClient接口上注解@FeignClient，声明为Feign的客户端，参数url指定服务端地址。<br>在spring boot启动类上增加注解@EnableFeignClients</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，HelloClient接口需要在启动类package或者子package之下。<br>编写测试类测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = FeignClientApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClientTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result = helloClient.hello(<span class="string">"ppdai"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动服务端后，运行该测试类，在控制台会打印出<code>Hello ppdai</code></p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>看到客户端测试类中，我们只用了一行代码，就能完成对远程Rest服务的调用，相当的简单。为什么这么神奇，这几段代码是如何做到的呢？</p><h2 id="EnableFeignClients-注解声明客户端接口"><a href="#EnableFeignClients-注解声明客户端接口" class="headerlink" title="@EnableFeignClients 注解声明客户端接口"></a>@EnableFeignClients 注解声明客户端接口</h2><p>入口是启动类上的注解@EnableFeignClients，源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line"><span class="comment">//basePackages的别名</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//声明基础包，spring boot启动后，会扫描该包下被@FeignClient注解的接口</span></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//声明基础包的类，通过该类声明基础包</span></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//默认配置类</span></span><br><span class="line">Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//直接声明的客户端接口类</span></span><br><span class="line">Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableFeignClients的参数声明客户端接口的位置和默认的配置类。</p><h3 id="FeignClient注解，将接口声明为Feign客户端"><a href="#FeignClient注解，将接口声明为Feign客户端" class="headerlink" title="@FeignClient注解，将接口声明为Feign客户端"></a>@FeignClient注解，将接口声明为Feign客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FeignClient &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">//名称，对应与eureka上注册的应用名</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">//生成spring bean的qualifier</span></span><br><span class="line"><span class="function">String <span class="title">qualifier</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">//http服务的url</span></span><br><span class="line"><span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">decode404</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"><span class="comment">//配置类，这里设置的配置类是Spring Configuration，将会在FeignContext中创建内部声明的Bean，用于不同的客户端进行隔离</span></span><br><span class="line">Class&lt;?&gt;[] configuration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//声明hystrix调用失败后的方法</span></span><br><span class="line">Class&lt;?&gt; fallback() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line">Class&lt;?&gt; fallbackFactory() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"><span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FeignClientsRegistrar-注册客户端"><a href="#FeignClientsRegistrar-注册客户端" class="headerlink" title="FeignClientsRegistrar 注册客户端"></a>FeignClientsRegistrar 注册客户端</h2><p>@EnableFeignClients注解上被注解了@Import(FeignClientsRegistrar.class)，@Import注解的作用是将指定的类作为Bean注入到Spring Context中，我们再来看被引入的FeignClientsRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">registerDefaultConfiguration(metadata, registry);</span><br><span class="line">registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignClientsRegistrar类实现了3个接口:</p><ul><li>接口ResourceLoaderAware用于注入ResourceLoader</li><li>接口BeanClassLoaderAware用于注入ClassLoader</li><li>接口ImportBeanDefinitionRegistrar用于动态向Spring Context中注册bean</li></ul><p>ImportBeanDefinitionRegistrar接口方法registerBeanDefinitions有两个参数</p><ul><li>AnnotationMetadata 包含被@Import注解类的信息</li></ul><blockquote><p>这里 @Import注解在@EnableFeignClients上，@EnableFeignClients注解在spring boot启动类上，AnnotationMetadata拿到的是spring boot启动类的相关信息</p></blockquote><ul><li>BeanDefinitionRegistry bean定义注册中心</li></ul><h2 id="registerDefaultConfiguration方法，注册默认配置"><a href="#registerDefaultConfiguration方法，注册默认配置" class="headerlink" title="registerDefaultConfiguration方法，注册默认配置"></a>registerDefaultConfiguration方法，注册默认配置</h2><p>registerDefaultConfiguration方法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取@EnableFeignClients注解参数</span></span><br><span class="line">Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//如果参数中包含defaultConfiguration</span></span><br><span class="line"><span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册客户端的配置Bean</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出@EnableFeignClients注解参数defaultConfiguration，注册到spring Context中。registerClientConfiguration方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">Object configuration)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个BeanDefinitionBuilder，注册bean的类为FeignClientSpecification</span></span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line"><span class="comment">//增加构造函数参数</span></span><br><span class="line">builder.addConstructorArgValue(name);</span><br><span class="line">builder.addConstructorArgValue(configuration);</span><br><span class="line"><span class="comment">//调用BeanDefinitionRegistry.registerBeanDefinition方法动态注册Bean</span></span><br><span class="line">registry.registerBeanDefinition(</span><br><span class="line">name + <span class="string">"."</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用spring 动态注册bean的方式，注册了一个FeignClientSpecification的bean。</p><h2 id="FeignClientSpecification-客户端定义"><a href="#FeignClientSpecification-客户端定义" class="headerlink" title="FeignClientSpecification 客户端定义"></a>FeignClientSpecification 客户端定义</h2><p>一个简单的pojo，继承了NamedContextFactory.Specification，两个属性String name 和 Class&lt;?&gt;[] configuration，用于FeignContext命名空间独立配置，后面会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientSpecification</span> <span class="keyword">implements</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] configuration;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="registerFeignClients方法，注册feign客户端"><a href="#registerFeignClients方法，注册feign客户端" class="headerlink" title="registerFeignClients方法，注册feign客户端"></a>registerFeignClients方法，注册feign客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成一个scanner，扫描注定包下的类</span></span><br><span class="line">ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line"><span class="comment">//包含@FeignClient注解的过滤器</span></span><br><span class="line">AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">FeignClient.class);</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">: (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line"><span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//@EnableFeignClients没有声明clients，获取basePackages，设置过滤器</span></span><br><span class="line">scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">basePackages = getBasePackages(metadata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//@EnableFeignClients声明了clients</span></span><br><span class="line"><span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//basePackages为声明的clients所在的包</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加过滤器，只包含声明的clients</span></span><br><span class="line">AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line"><span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">scanner.addIncludeFilter(</span><br><span class="line"><span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历basePackages</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">//扫描包，根据过滤器找到候选的Bean</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">.findCandidateComponents(basePackage);</span><br><span class="line"><span class="comment">// 遍历候选的bean</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 校验注解是否是注解在接口上</span></span><br><span class="line">AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line"><span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line"><span class="comment">// 获取注解属性</span></span><br><span class="line">Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">.getAnnotationAttributes(</span><br><span class="line">FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">String name = getClientName(attributes);</span><br><span class="line"><span class="comment">//注册客户端配置</span></span><br><span class="line">registerClientConfiguration(registry, name,</span><br><span class="line">attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line"><span class="comment">//注册客户端</span></span><br><span class="line">registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要逻辑是扫描注解声明的客户端，调用registerFeignClient方法注册到registry中。这里是一个典型的spring动态注册bean的例子，可以参考这段代码在spring中轻松的实现类路径下class扫描，动态注册bean到spring中。想了解spring类的扫描机制，可以断点到ClassPathScanningCandidateComponentProvider.findCandidateComponents方法中，一步步调试。</p><h2 id="registerFeignClient方法，注册单个客户feign端"><a href="#registerFeignClient方法，注册单个客户feign端" class="headerlink" title="registerFeignClient方法，注册单个客户feign端"></a>registerFeignClient方法，注册单个客户feign端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">String className = annotationMetadata.getClassName();</span><br><span class="line"><span class="comment">//构建一个FeignClientFactoryBean的bean工厂定义</span></span><br><span class="line">BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">validate(attributes);</span><br><span class="line"><span class="comment">//根据@FeignClient注解的参数，设置属性</span></span><br><span class="line">definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">String name = getName(attributes);</span><br><span class="line">definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">String alias = name + <span class="string">"FeignClient"</span>;</span><br><span class="line">AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line">beanDefinition.setPrimary(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置qualifier</span></span><br><span class="line">String qualifier = getQualifier(attributes);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">alias = qualifier;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册，这里为了简写，新建一个BeanDefinitionHolder，调用BeanDefinitionReaderUtils静态方法注册</span></span><br><span class="line">BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line"><span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerFeignClient方法主要是将FeignClientFactoryBean工厂Bean注册到registry中，spring初始化后，会调用FeignClientFactoryBean的getObject方法创建bean注册到spring context中。</p><h2 id="FeignClientFactoryBean-创建feign客户端的工厂"><a href="#FeignClientFactoryBean-创建feign客户端的工厂" class="headerlink" title="FeignClientFactoryBean 创建feign客户端的工厂"></a>FeignClientFactoryBean 创建feign客户端的工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;, <span class="title">InitializingBean</span>,</span></span><br><span class="line"><span class="class"><span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">//feign客户端接口类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="keyword">private</span> String name;  </span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> decode404;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"><span class="comment">//hystrix集成，调用失败的执行方法</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; fallback = <span class="keyword">void</span>.class;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; fallbackFactory = <span class="keyword">void</span>.class;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignClientFactoryBean实现了FactoryBean接口，是一个工厂bean</p><h3 id="FeignClientFactoryBean-getObject方法"><a href="#FeignClientFactoryBean-getObject方法" class="headerlink" title="FeignClientFactoryBean.getObject方法"></a>FeignClientFactoryBean.getObject方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//FeignContext在FeignAutoConfiguration中自动注册，FeignContext用于客户端配置类独立注册，后面具体分析</span></span><br><span class="line">FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line"><span class="comment">//创建Feign.Builder</span></span><br><span class="line">Feign.Builder builder = feign(context);</span><br><span class="line"><span class="comment">//如果@FeignClient注解没有设置url参数</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">String url;</span><br><span class="line"><span class="comment">//url为@FeignClient注解的name参数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">url = <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加上path</span></span><br><span class="line">url += cleanPath();</span><br><span class="line"><span class="comment">//返回loadBlance客户端，也就是ribbon+eureka的客户端</span></span><br><span class="line"><span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line"><span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@FeignClient设置了url参数，不做负载均衡</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line"><span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加上path</span></span><br><span class="line">String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line"><span class="comment">//从FeignContext中获取client</span></span><br><span class="line">Client client = getOptional(context, Client.class);</span><br><span class="line"><span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line"><span class="comment">// 有url参数，不做负载均衡，但是客户端是ribbon，或者实际的客户端</span></span><br><span class="line">client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">&#125;</span><br><span class="line">builder.client(client);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从FeignContext中获取Targeter</span></span><br><span class="line">Targeter targeter = get(context, Targeter.class);</span><br><span class="line"><span class="comment">//生成客户端代理</span></span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line"><span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有个比较重要的逻辑，如果在@FeignClient注解中设置了url参数，就不走Ribbon，直接url调用，否则通过Ribbon调用，实现客户端负载均衡。</p><p>可以看到，生成Feign客户端所需要的各种配置对象，都是通过FeignContex中获取的。</p><h3 id="FeignContext-隔离配置"><a href="#FeignContext-隔离配置" class="headerlink" title="FeignContext 隔离配置"></a>FeignContext 隔离配置</h3><p>在@FeignClient注解参数configuration，指定的类是Spring的Configuration Bean，里面方法上加@Bean注解实现Bean的注入，可以指定feign客户端的各种配置，包括Encoder/Decoder/Contract/Feign.Builder等。不同的客户端指定不同配置类，就需要对配置类进行隔离，FeignContext就是用于隔离配置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignContext</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">FeignClientSpecification</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FeignContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(FeignClientsConfiguration.class, <span class="string">"feign"</span>, <span class="string">"feign.client.name"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignContext继承NamedContextFactory，空参数构造函数指定FeignClientsConfiguration类为默认配置。<br>NamedContextFactory实现接口ApplicationContextAware，注入ApplicationContextAware作为parent：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedContextFactory</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">NamedContextFactory</span>.<span class="title">Specification</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">//命名空间对应的Spring Context</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//不同命名空间的定义</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, C&gt; configurations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//父ApplicationContext，通过ApplicationContextAware接口注入</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext parent;</span><br><span class="line"><span class="comment">//默认配置类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defaultConfigType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertySourceName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String propertyName;</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//设置配置，在FeignAutoConfiguration中将Spring Context中的所有FeignClientSpecification设置进来，如果@EnableFeignClients有设置参数defaultConfiguration也会加进来，前面已经分析在registerDefaultConfiguration方法中注册的FeignClientSpecification Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurations</span><span class="params">(List&lt;C&gt; configurations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (C client : configurations) &#123;</span><br><span class="line"><span class="keyword">this</span>.configurations.put(client.getName(), client);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定命名空间的ApplicationContext，先从缓存中获取，没有就创建</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建ApplicationContext</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建AnnotationConfigApplicationContext</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"><span class="comment">//根据name在configurations找到所有的配置类，注册到context总</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将default.开头的默认默认也注册到Context中</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"default."</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册一些需要的bean</span></span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration.class,</span><br><span class="line"><span class="keyword">this</span>.defaultConfigType);</span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 设置parent</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//刷新，完成bean生成</span></span><br><span class="line">context.refresh();</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从命名空间中获取指定类型的Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从命名空间中获取指定类型的Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getInstances</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">type).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> BeanFactoryUtils.beansOfTypeIncludingAncestors(context, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键的方法是createContext，为每个命名空间独立创建ApplicationContext，设置parent为外部传入的Context，这样就可以共用外部的Context中的Bean，又有各种独立的配置Bean，熟悉springMVC的同学应该知道，springMVC中创建的WebApplicatonContext里面也有个parent，原理跟这个类似。</p><p>从FeignContext中获取Bean，需要传入命名空间，根据命名空间找到缓存中的ApplicationContext，先从自己注册的Bean中获取bean，没有获取到再从到parent中获取。</p><h3 id="创建Feign-Builder"><a href="#创建Feign-Builder" class="headerlink" title="创建Feign.Builder"></a>创建Feign.Builder</h3><p>了解了FeignContext的原理，我们再来看feign最重要的构建类创建过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//从FeignContext中获取注册的Feign.Builder bean，设置Encoder/Decoder/Contract</span></span><br><span class="line">Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">.logger(logger)</span><br><span class="line">.encoder(get(context, Encoder.class))</span><br><span class="line">.decoder(get(context, Decoder.class))</span><br><span class="line">.contract(get(context, Contract.class));</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//设置feign其他参数，都从FeignContext中获取</span></span><br><span class="line">Retryer retryer = getOptional(context, Retryer.class);</span><br><span class="line"><span class="keyword">if</span> (retryer != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.retryer(retryer);</span><br><span class="line">&#125;</span><br><span class="line">ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder.class);</span><br><span class="line"><span class="keyword">if</span> (errorDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.errorDecoder(errorDecoder);</span><br><span class="line">&#125;</span><br><span class="line">Request.Options options = getOptional(context, Request.Options.class);</span><br><span class="line"><span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.options(options);</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, RequestInterceptor&gt; requestInterceptors = context.getInstances(</span><br><span class="line"><span class="keyword">this</span>.name, RequestInterceptor.class);</span><br><span class="line"><span class="keyword">if</span> (requestInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.requestInterceptors(requestInterceptors.values());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (decode404) &#123;</span><br><span class="line">builder.decode404();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里设置了Feign.Builder所必须的参数Encoder/Decoder/Contract，其他参数都是可选的。这三个必须的参数从哪里来的呢？答案是在FeignContext的构造器中，传入了默认的配置FeignClientsConfiguration，这个配置类里面初始化了这三个参数。</p><h3 id="FeignClientsConfiguration-客户端默认配置"><a href="#FeignClientsConfiguration-客户端默认配置" class="headerlink" title="FeignClientsConfiguration 客户端默认配置"></a>FeignClientsConfiguration 客户端默认配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientsConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//注入springMVC的HttpMessageConverters</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"><span class="comment">//注解参数处理器，处理SpringMVC注解，生成http元数据</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;AnnotatedParameterProcessor&gt; parameterProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//Decoder bean，默认通过HttpMessageConverters进行处理</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Decoder <span class="title">feignDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseEntityDecoder(<span class="keyword">new</span> SpringDecoder(<span class="keyword">this</span>.messageConverters));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Encoder bean，默认通过HttpMessageConverters进行处理</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Encoder <span class="title">feignEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringEncoder(<span class="keyword">this</span>.messageConverters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Contract bean，通过SpringMvcContract进行处理接口</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">(ConversionService feignConversionService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringMvcContract(<span class="keyword">this</span>.parameterProcessors, feignConversionService);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hystrix自动注入</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//HystrixFeign的builder，全局关掉Hystrix配置feign.hystrix.enabled=false</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"feign.hystrix.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认不重试</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retryer <span class="title">feignRetryer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Retryer.NEVER_RETRY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认的builder</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">(Retryer retryer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Feign.builder().retryer(retryer);</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，feign需要的decoder/enoder通过适配器共用springMVC中的HttpMessageConverters引入。</p><p>feign有自己的注解体系，这里通过SpringMvcContract适配了springMVC的注解体系。</p><h3 id="SpringMvcContract-适配feign注解体系"><a href="#SpringMvcContract-适配feign注解体系" class="headerlink" title="SpringMvcContract 适配feign注解体系"></a>SpringMvcContract 适配feign注解体系</h3><p>SpringMvcContract继承了feign的类Contract.BaseContract，作用是解析接口方法上的注解和方法参数，生成MethodMetadata用于接口方法调用过程中组装http请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcContract</span> <span class="keyword">extends</span> <span class="title">Contract</span>.<span class="title">BaseContract</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理Class上的注解</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnClass</span><span class="params">(MethodMetadata data, Class&lt;?&gt; clz)</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodMetadata <span class="title">parseAndValidateMetadata</span><span class="params">(Class&lt;?&gt; targetType, Method method)</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理方法上的注解</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">Annotation methodAnnotation, Method method)</span> </span>&#123;</span><br><span class="line">        。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理参数上的注解</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processAnnotationsOnParameter</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">  Annotation[] annotations, <span class="keyword">int</span> paramIndex)</span> </span>&#123;</span><br><span class="line">  。。。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个覆盖方法分别是处理类上的注解，处理方法，处理方法上的注解，处理方法参数注解，最终生成完整的MethodMetadata。feign自己提供的Contract和扩展javax.ws.rx的Contract原理都是类似的。</p><h3 id="Targeter-生成接口动态代理"><a href="#Targeter-生成接口动态代理" class="headerlink" title="Targeter 生成接口动态代理"></a>Targeter 生成接口动态代理</h3><p>Feign.Builder生成后，就要用Target生成feign客户端的动态代理，这里FeignClientFactoryBean中使用Targeter，Targeter有两个实现类，分别是HystrixTargeter和DefaultTargeter，DefaultTargeter很简单，直接调用HardCodedTarget生成动态代理，HystrixTargeter源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HystrixTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果不是HystrixFeign.Builder，直接调用target生成代理</span></span><br><span class="line"><span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line"><span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到fallback或者fallbackFactory，设置到hystrix中</span></span><br><span class="line">feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line"><span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line"><span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line"><span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line"><span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，接口的动态代理就生成了，然后回到FeignClientFactoryBean工厂bean中，会将动态代理注入到SpringContext，在使用的地方，就可以通过@Autowire方式注入了。</p><h2 id="loadBalance方法，客户端负载均衡"><a href="#loadBalance方法，客户端负载均衡" class="headerlink" title="loadBalance方法，客户端负载均衡"></a>loadBalance方法，客户端负载均衡</h2><p>如果@FeignClient注解中没有配置url参数，将会通过loadBalance方法生成Ribbon的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里获取到的Client是LoadBalancerFeignClient</span></span><br><span class="line">Client client = getOptional(context, Client.class);</span><br><span class="line"><span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.client(client);</span><br><span class="line">Targeter targeter = get(context, Targeter.class);</span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoadBalancerFeignClient在FeignRibbonClientAutoConfiguration中自动配置的Bean</p><h3 id="LoadBalancerFeignClient-负载均衡客户端"><a href="#LoadBalancerFeignClient-负载均衡客户端" class="headerlink" title="LoadBalancerFeignClient 负载均衡客户端"></a>LoadBalancerFeignClient 负载均衡客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerFeignClient</span> <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">。。。</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取URI</span></span><br><span class="line">URI asUri = URI.create(request.url());</span><br><span class="line"><span class="comment">//获取客户端的名称</span></span><br><span class="line">String clientName = asUri.getHost();</span><br><span class="line">URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line"><span class="comment">//创建RibbonRequest</span></span><br><span class="line">FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line"><span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line"><span class="comment">//配置</span></span><br><span class="line">IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line"><span class="comment">//获取FeignLoadBalancer，发请求，转换Response</span></span><br><span class="line"><span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">requestConfig).toResponse();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑也比较简单，就是是配到Ribbon客户端上调用。Ribbon的相关使用和原理就不在本文中描述。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>feign本身是一款优秀的开源组件，spring cloud feign又非常巧妙的将feign集成到spring boot中。<br>本文通过对spring cloud feign源代码的解读，详细的分析了feign集成到spring boot中的原理，使我们更加全面的了解到feign的使用。</p><p>spring cloud feign也是一个很好的学习spring boot的例子，从中我们可以学习到：</p><ul><li>spring boot注解声明注入bean</li><li>spring类扫描机制</li><li>spring接口动态注册bean</li><li>spring命名空间隔离ApplicationContext</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OpenFeign/feign&quot;&gt;feign&lt;/a&gt;是一个声明试的HTTP客户端，spring-cloud-openfeign将feign集成到spring boot中，在接口上通过注解声明Rest协议，将http调用转换为接口方法的调用，使得客户端调用http服务更加简单。&lt;/p&gt;
&lt;p&gt;当前spring cloud最新稳定版本是Edgware，feign在其集成的&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-netflix&quot;&gt;spring-cloud-netflix&lt;/a&gt; 1.4.0.RELEASE版本中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spring cloud下一个版本是Finchley，将会单独集成&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-openfeign&quot;&gt;spring-cloud-openfeign&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="spring" scheme="https://github.com/along101/categories/spring/"/>
    
    
      <category term="feign" scheme="https://github.com/along101/tags/feign/"/>
    
      <category term="rest" scheme="https://github.com/along101/tags/rest/"/>
    
      <category term="spring-cloud" scheme="https://github.com/along101/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Feign使用教程，翻译版本</title>
    <link href="https://github.com/along101/2018/06/14/feign-user-guide/"/>
    <id>https://github.com/along101/2018/06/14/feign-user-guide/</id>
    <published>2018-06-14T04:03:13.000Z</published>
    <updated>2018-07-13T07:39:40.957Z</updated>
    
    <content type="html"><![CDATA[<p>英文原文请参考:<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a><br>翻译参考:<a href="https://blog.csdn.net/u010862794/article/details/73649616" target="_blank" rel="noopener">https://blog.csdn.net/u010862794/article/details/73649616</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Feign是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于<a href="https://github.com/square/retrofit">Retrofit</a>, <a href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html" target="_blank" rel="noopener">JAXRS-2.0</a>和<a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="noopener">WebSocket</a>。Feign 最初是为了降低统一绑定<a href="https://github.com/Netflix/Denominator">Denominator</a> 到 HTTP API 的复杂度，不区分是否支持 <a href="http://www.slideshare.net/adrianfcole/99problems" target="_blank" rel="noopener">ReSTfulness</a>。</p><a id="more"></a><h3 id="为什么选择Feign而不是其他"><a href="#为什么选择Feign而不是其他" class="headerlink" title="为什么选择Feign而不是其他"></a>为什么选择Feign而不是其他</h3><p>你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。你也可以直接使用 Apache HttpClient 来实现。但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。</p><h3 id="Feign工作机制"><a href="#Feign工作机制" class="headerlink" title="Feign工作机制"></a>Feign工作机制</h3><p>Feign 通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。然而这也限制了 Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>基本的使用如下所示，一个对于<a href="https://github.com/square/retrofit/blob/master/samples/src/main/java/com/example/retrofit/SimpleService.java">canonical Retrofit sample</a>的适配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">  String login;</span><br><span class="line">  <span class="keyword">int</span> contributions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  GitHub github = Feign.builder()</span><br><span class="line">                       .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                       .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">  List&lt;Contributor&gt; contributors = github.contributors(<span class="string">"OpenFeign"</span>, <span class="string">"feign"</span>);</span><br><span class="line">  <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">    System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>Feign 有许多可以自定义的方面。举个简单的例子，你可以使用 <code>Feign.builder()</code> 来构造一个拥有你自己组件的API接口。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /account/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">Account <span class="title">getAccountInfo</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// AccountDecoder 是自己实现的一个Decoder</span></span><br><span class="line">Bank bank = Feign.builder().decoder(<span class="keyword">new</span> AccountDecoder()).target(Bank.class, <span class="string">"https://api.examplebank.com"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="多种接口"><a href="#多种接口" class="headerlink" title="多种接口"></a>多种接口</h3><p>Feign可以提供多种API接口，这些接口都被定义为 <code>Target&lt;T&gt;</code> (默认的实现是 <code>HardCodedTarget&lt;T&gt;</code>), 它允许在执行请求前动态发现和装饰该请求。</p><p>举个例子，下面的这个模式允许使用当前url和身份验证token来装饰每个发往身份验证中心服务的请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloudDNS cloudDNS = Feign.builder().target(<span class="keyword">new</span> CloudIdentityTarget&lt;CloudDNS&gt;(user, apiKey));</span><br></pre></td></tr></table></figure></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>Feign 包含了 <a href="./example-github">GitHub</a> 和 <a href="./example-wikipedia">Wikipedia</a>  客户端的实现样例.相似的项目也同样在实践中运用了Feign。尤其是它的示例后台程序<a href="https://github.com/Netflix/denominator/tree/master/example-daemon">example daemon</a>。</p><h3 id="Feign集成模块"><a href="#Feign集成模块" class="headerlink" title="Feign集成模块"></a>Feign集成模块</h3><p>Feign 可以和其他的开源工具集成工作。你可以将这些开源工具集成到 Feign 中来。目前已经有的一些模块如下:</p><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>Gson 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。<br>添加 <code>GsonEncoder</code> 以及 <code>GsonDecoder</code> 到你的 <code>Feign.Builder</code> 中， 如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GsonCodec codec = <span class="keyword">new</span> GsonCodec();</span><br><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><h3 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h3><p>Jackson 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。<br>添加 <code>JacksonEncoder</code> 以及 <code>JacksonDecoder</code> 到你的 <code>Feign.Builder</code> 中， 如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .encoder(<span class="keyword">new</span> JacksonEncoder())</span><br><span class="line">                     .decoder(<span class="keyword">new</span> JacksonDecoder())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-jackson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Sax"><a href="#Sax" class="headerlink" title="Sax"></a>Sax</h3><p>SaxDecoder 用于解析XML,并兼容普通JVM和Android。下面是一个配置sax来解析响应的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api = Feign.builder()</span><br><span class="line">           .decoder(SAXDecoder.builder()</span><br><span class="line">                              .registerContentHandler(UserIdHandler.class)</span><br><span class="line">                              .build())</span><br><span class="line">           .target(Api.class, <span class="string">"https://apihost"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-sax&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="JAXB"><a href="#JAXB" class="headerlink" title="JAXB"></a>JAXB</h3><p>JAXB 包含了一个编码器和一个解码器，这个可以被用于XML格式的API。<br>添加  <code>JAXBEncoder</code> 以及  <code>JAXBDecoder</code> 到你的  <code>Feign.Builder</code> 中， 如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api = Feign.builder()</span><br><span class="line">           .encoder(<span class="keyword">new</span> JAXBEncoder())</span><br><span class="line">           .decoder(<span class="keyword">new</span> JAXBDecoder())</span><br><span class="line">           .target(Api.class, <span class="string">"https://apihost"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-jaxb&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="JAX-RS"><a href="#JAX-RS" class="headerlink" title="JAX-RS"></a>JAX-RS</h3><p>JAXRSContract 使用 JAX-RS 规范重写覆盖了默认的注解处理。下面是一个使用 JAX-RS 的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span> <span class="meta">@Path</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@PathParam(<span class="string">"owner"</span>)</span> String owner, @<span class="title">PathParam</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .contract(<span class="keyword">new</span> JAXRSContract())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><p>Maven依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-jaxrs&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><p>OkHttpClient 使用 OkHttp 来发送 Feign 的请求，OkHttp 支持 SPDY (SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验),并有更好的控制http请求。</p><p>要让 Feign 使用 OkHttp ，你需要将 OkHttp 加入到你的环境变量中区，然后配置 Feign 使用  <code>OkHttpClient</code>，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>RibbonClient 重写了 Feign 客户端的对URL的处理，其添加了 智能路由以及一些其他由Ribbon提供的弹性功能。<br>集成Ribbon需要你将ribbon的客户端名称当做url的host部分来传递，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAppProd是你的ribbon client name</span></span><br><span class="line">MyService api = Feign.builder().client(RibbonClient.create()).target(MyService.class, <span class="string">"https://myAppProd"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-ribbon&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>HystrixFeign 配置了 Hystrix 提供的熔断机制。<br>要在 Feign 中使用 Hystrix ，你需要添加Hystrix模块到你的环境变量，然后使用  <code>HystrixFeign</code> 来构造你的API:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyService api = HystrixFeign.builder().target(MyService.class, <span class="string">"https://myAppProd"</span>);</span><br></pre></td></tr></table></figure></p><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h3><p>SLF4JModule 允许你使用 SLF4J 作为 Feign 的日志记录模块，这样你就可以轻松的使用 Logback, Log4J , 等来记录你的日志.</p><p>要在 Feign 中使用 SLF4J ，你需要添加SLF4J模块和对应的日志记录实现模块(比如Log4J)到你的环境变量，然后配置Feign使用Slf4jLogger :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .logger(<span class="keyword">new</span> Slf4jLogger())</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure><p>Maven依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-slf4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Decoders"><a href="#Decoders" class="headerlink" title="Decoders"></a>Decoders</h3><p> <code>Feign.builder()</code> 允许你自定义一些额外的配置，比如说如何解码一个响应。假如有接口方法返回的消息不是  <code>Response</code>,  <code>String</code>,  <code>byte[]</code> 或者  <code>void</code> 类型的，那么你需要配置一个非默认的解码器。<br>下面是一个配置使用JSON解码器(使用的是feign-gson扩展)的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(new GsonDecoder())</span><br><span class="line">                     .target(GitHub.class, &quot;https://api.github.com&quot;);</span><br></pre></td></tr></table></figure></p><p>假如你想在将响应传递给解码器处理前做一些额外的处理，那么你可以使用 <code>mapAndDecode</code> 方法。一个用例就是使用jsonp服务的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JsonpApi jsonpApi = Feign.builder()</span><br><span class="line">                         .mapAndDecode((response, type) -&gt; jsopUnwrap(response, type), new GsonDecoder())</span><br><span class="line">                         .target(JsonpApi.class, &quot;https://some-jsonp-api.com&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="Encoders"><a href="#Encoders" class="headerlink" title="Encoders"></a>Encoders</h3><p>发送一个Post请求最简单的方法就是传递一个 <code>String</code> 或者 <code>byte[]</code> 类型的参数了。你也许还需添加一个<code>Content-Type</code>请求头，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">client.login(<span class="string">"&#123;\"user_name\": \"denominator\", \"password\": \"secret\"&#125;"</span>);</span><br></pre></td></tr></table></figure></p><p>通过配置一个解码器，你可以发送一个安全类型的请求体，如下是一个使用 feign-gson 扩展的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String user_name;</span><br><span class="line">  <span class="keyword">final</span> String password;</span><br><span class="line"></span><br><span class="line">  Credentials(String user_name, String password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.user_name = user_name;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(Credentials creds)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">LoginClient client = Feign.builder()</span><br><span class="line">                          .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                          .target(LoginClient.class, <span class="string">"https://foo.com"</span>);</span><br><span class="line"></span><br><span class="line">client.login(<span class="keyword">new</span> Credentials(<span class="string">"denominator"</span>, <span class="string">"secret"</span>));</span><br></pre></td></tr></table></figure></p><h3 id="Body-templates"><a href="#Body-templates" class="headerlink" title="@Body templates"></a>@Body templates</h3><p><code>@Body</code>注解申明一个请求体模板，模板中可以带有参数，与方法中 <code>@Param</code> 注解申明的参数相匹配,使用方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/xml"</span>)</span><br><span class="line">  <span class="meta">@Body</span>(<span class="string">"&lt;login \"user_name\"=\"&#123;user_name&#125;\" \"password\"=\"&#123;password&#125;\"/&gt;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">xml</span><span class="params">(@Param(<span class="string">"user_name"</span>)</span> String user, @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="comment">// json curly braces must be escaped!</span></span><br><span class="line">  <span class="comment">// 这里JSON格式需要的花括号居然需要转码，有点蛋疼了。</span></span><br><span class="line">  <span class="meta">@Body</span>(<span class="string">"%7B\"user_name\": \"&#123;user_name&#125;\", \"password\": \"&#123;password&#125;\"%7D"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">json</span><span class="params">(@Param(<span class="string">"user_name"</span>)</span> String user, @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// &lt;login "user_name"="denominator" "password"="secret"/&gt;</span></span><br><span class="line">client.xml(<span class="string">"denominator"</span>, <span class="string">"secret"</span>);</span><br><span class="line"><span class="comment">// &#123;"user_name": "denominator", "password": "secret"&#125;</span></span><br><span class="line">client.json(<span class="string">"denominator"</span>, <span class="string">"secret"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Feign 支持给请求的api设置或者请求的客户端设置请求头</p><ul><li><p>使用 <code>@Headers</code> 设置静态请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给BaseApi中的所有方法设置Accept请求头</span></span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"Accept: application/json"</span>)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 单独给put方法设置Content-Type请求头</span></span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"PUT /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置动态值的请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"X-Ping: &#123;token&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(@Param(<span class="string">"token"</span>)</span> String token)</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置key和value都是动态的请求头<br>有些API需要根据调用时动态确定使用不同的请求头(e.g. custom metadata header fields such as “x-amz-meta-” or “x-goog-meta-“),这时候可以使用 <code>@HeaderMap</code> 注解，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @HeaderMap 注解设置的请求头优先于其他方式设置的</span></span><br><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(@HeaderMap Map&lt;String, Object&gt; headerMap)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="给Target设置请求头"><a href="#给Target设置请求头" class="headerlink" title="给Target设置请求头"></a>给Target设置请求头</h3><p>有时我们需要在一个API实现中根据不同的endpoint来传入不同的Header，这个时候我们可以使用自定义的<code>RequestInterceptor</code> 或 <code>Target</code>来实现.<br>通过自定义的 <code>RequestInterceptor</code> 来实现请查看 <code>Request Interceptors</code> 章节.<br>下面是一个通过自定义<code>Targe</code>t来实现给每个<code>Target</code>设置安全校验信息Header的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAuthTokenTarget</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Target</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicAuthTokenTarget</span><span class="params">(Class&lt;T&gt; clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">                                UrlAndTokenProvider provider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ThreadLocal&lt;String&gt; requestIdProvider)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Request <span class="title">apply</span><span class="params">(RequestTemplate input)</span> </span>&#123;</span><br><span class="line">    TokenIdAndPublicURL urlAndToken = provider.get();</span><br><span class="line">    <span class="keyword">if</span> (input.url().indexOf(<span class="string">"http"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      input.insert(<span class="number">0</span>, urlAndToken.publicURL);</span><br><span class="line">    &#125;</span><br><span class="line">    input.header(<span class="string">"X-Auth-Token"</span>, urlAndToken.tokenId);</span><br><span class="line">    input.header(<span class="string">"X-Request-ID"</span>, requestIdProvider.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input.request();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Bank bank = Feign.builder()</span><br><span class="line">        .target(<span class="keyword">new</span> DynamicAuthTokenTarget(Bank.class, provider, requestIdProvider));</span><br></pre></td></tr></table></figure></p><p>这种方法的实现依赖于给Feign 客户端设置的自定义的<code>RequestInterceptor</code> 或 <code>Target</code>。可以被用来给一个客户端的所有api请求设置请求头。比如说可是被用来在header中设置身份校验信息。这些方法是在线程执行api请求的时候才会执行，所以是允许在运行时根据上下文来动态设置header的。<br>比如说可以根据线程本地存储(thread-local storage)来为不同的线程设置不同的请求头。</p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="Base-APIS"><a href="#Base-APIS" class="headerlink" title="Base APIS"></a>Base APIS</h4><p>有些请求中的一些方法是通用的，但是可能会有不同的参数类型或者返回类型，这个时候可以这么用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用API</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /health"</span>)</span><br><span class="line">  <span class="function">String <span class="title">health</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /all"</span>)</span><br><span class="line">  <span class="function">List&lt;Entity&gt; <span class="title">all</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承通用API</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomAPI</span> <span class="keyword">extends</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /custom"</span>)</span><br><span class="line">  <span class="function">String <span class="title">custom</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种类型有相同的表现形式，定义一个统一的API</span></span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"Accept: application/json"</span>)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /api"</span>)</span><br><span class="line">  <span class="function">List&lt;V&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"PUT /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String key, V value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同的类型来继承</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Foo</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BarApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Bar</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h4><p>你可以通过设置一个 <code>Logger</code> 来记录http消息，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .logger(<span class="keyword">new</span> Logger.JavaLogger().appendToFile(<span class="string">"logs/http.log"</span>))</span><br><span class="line">                     .logLevel(Logger.Level.FULL)</span><br><span class="line">                     .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br></pre></td></tr></table></figure></p><p>也可以参考上面的 SLF4J 章节的说明</p><h4 id="Request-Interceptors"><a href="#Request-Interceptors" class="headerlink" title="Request Interceptors"></a>Request Interceptors</h4><p>当你希望修改所有的的请求的时候，你可以使用<code>Request Interceptors</code>。比如说，你作为一个中介，你可能需要为每个请求设置 <code>X-Forwarded-For</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardedForInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">    template.header(<span class="string">"X-Forwarded-For"</span>, <span class="string">"origin.host.com"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Bank bank = Feign.builder()</span><br><span class="line">                 .decoder(accountDecoder)</span><br><span class="line">                 .requestInterceptor(<span class="keyword">new</span> ForwardedForInterceptor())</span><br><span class="line">                 .target(Bank.class, <span class="string">"https://api.examplebank.com"</span>);</span><br></pre></td></tr></table></figure></p><p>或者，你可能需要实现Basic Auth，这里有一个内置的基础校验拦截器 <code>BasicAuthRequestInterceptor</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bank bank = Feign.builder()</span><br><span class="line">                 .decoder(accountDecoder)</span><br><span class="line">                 .requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(username, password))</span><br><span class="line">                 .target(Bank.class, <span class="string">"https://api.examplebank.com"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="Custom-Param-Expansion"><a href="#Custom-Param-Expansion" class="headerlink" title="Custom @Param Expansion"></a>Custom @Param Expansion</h4><p>在使用 <code>@Param</code> 注解给模板中的参数设值的时候，默认的是使用的对象的 <code>toString()</code> 方法的值，通过声明 自定义的<code>Param.Expander</code>，用户可以控制其行为，比如说格式化 <code>Date</code> 类型的值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过设置 @Param 的 expander 为 DateToMillis.class 可以定义Date类型的值</span></span><br><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"GET /?since=&#123;date&#125;"</span>)</span><br><span class="line"><span class="function">Result <span class="title">list</span><span class="params">(@Param(value = <span class="string">"date"</span>, expander = DateToMillis.class)</span> Date date)</span>;</span><br></pre></td></tr></table></figure></p><h4 id="Dynamic-Query-Parameters"><a href="#Dynamic-Query-Parameters" class="headerlink" title="Dynamic Query Parameters"></a>Dynamic Query Parameters</h4><p>动态查询参数支持，通过使用 <code>@QueryMap</code> 可以允许动态传入请求参数,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"GET /find"</span>)</span><br><span class="line"><span class="function">V <span class="title">find</span><span class="params">(@QueryMap Map&lt;String, Object&gt; queryMap)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="Static-and-Default-Methods"><a href="#Static-and-Default-Methods" class="headerlink" title="Static and Default Methods"></a>Static and Default Methods</h4><p>如果你使用的是JDK 1.8+ 的话，那么你可以给接口设置统一的默认方法和静态方法,这个事JDK8的新特性，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /users/&#123;username&#125;/repos?sort=&#123;sort&#125;"</span>)</span><br><span class="line">  <span class="function">List&lt;Repo&gt; <span class="title">repos</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"sort"</span>)</span> String sort)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Repo&gt; <span class="title">repos</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repos(owner, <span class="string">"full_name"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lists all contributors for all repos owned by a user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">    MergingContributorList contributors = <span class="keyword">new</span> MergingContributorList();</span><br><span class="line">    <span class="keyword">for</span>(Repo repo : <span class="keyword">this</span>.repos(owner)) &#123;</span><br><span class="line">      contributors.addAll(<span class="keyword">this</span>.contributors(user, repo.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contributors.mergeResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GitHub <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Feign.builder()</span><br><span class="line">                .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英文原文请参考:&lt;a href=&quot;https://github.com/OpenFeign/feign&quot;&gt;https://github.com/OpenFeign/feign&lt;/a&gt;&lt;br&gt;翻译参考:&lt;a href=&quot;https://blog.csdn.net/u010862794/article/details/73649616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u010862794/article/details/73649616&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Feign是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于&lt;a href=&quot;https://github.com/square/retrofit&quot;&gt;Retrofit&lt;/a&gt;, &lt;a href=&quot;https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAXRS-2.0&lt;/a&gt;和&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebSocket&lt;/a&gt;。Feign 最初是为了降低统一绑定&lt;a href=&quot;https://github.com/Netflix/Denominator&quot;&gt;Denominator&lt;/a&gt; 到 HTTP API 的复杂度，不区分是否支持 &lt;a href=&quot;http://www.slideshare.net/adrianfcole/99problems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReSTfulness&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="https://github.com/along101/categories/spring/"/>
    
    
      <category term="java" scheme="https://github.com/along101/tags/java/"/>
    
      <category term="feign" scheme="https://github.com/along101/tags/feign/"/>
    
      <category term="rest" scheme="https://github.com/along101/tags/rest/"/>
    
  </entry>
  
  <entry>
    <title>feign源码解析</title>
    <link href="https://github.com/along101/2018/06/13/feign-source-analysis/"/>
    <id>https://github.com/along101/2018/06/13/feign-source-analysis/</id>
    <published>2018-06-13T04:03:13.000Z</published>
    <updated>2018-07-13T07:39:49.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="feign介绍"><a href="#feign介绍" class="headerlink" title="feign介绍"></a>feign介绍</h2><p><a href="https://github.com/OpenFeign/feign/">Feign</a>是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于<a href="https://github.com/square/retrofit">Retrofit</a>, <a href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html" target="_blank" rel="noopener">JAXRS-2.0</a>和<a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="noopener">WebSocket</a>。feign在github上有近3K个star，是一款相当优秀的开源组件，虽然相比Retrofit的近30K个star，逊色了太多，但是spring cloud集成了feign，使得feign在java生态中比Retrofit使用的更加广泛。</p><p>feign的基本原理是在接口方法上加注解，定义rest请求，构造出接口的动态代理对象，然后通过调用接口方法就可以发送http请求，并且自动解析http响应为方法返回值，极大的简化了客户端调用rest api的代码。官网的示例如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">  String login;</span><br><span class="line">  <span class="keyword">int</span> contributions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  GitHub github = Feign.builder()</span><br><span class="line">                       .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                       .target(GitHub.class, <span class="string">"https://api.github.com"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">  List&lt;Contributor&gt; contributors = github.contributors(<span class="string">"OpenFeign"</span>, <span class="string">"feign"</span>);</span><br><span class="line">  <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">    System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feign使用教程请参考官网<a href="https://github.com/OpenFeign/feign/">https://github.com/OpenFeign/feign/</a></p><p>本文主要是对feign源码进行分析，根据源码来理解feign的设计架构和内部实现技术。  </p><h2 id="Feign-build-构建接口动态代理"><a href="#Feign-build-构建接口动态代理" class="headerlink" title="Feign.build 构建接口动态代理"></a><code>Feign.build</code> 构建接口动态代理</h2><p>我们先来看看接口的动态代理是如何构建出来的，下图是主要接口和类的类图：</p><p><img src="/images/feign/init1.png" alt=""></p><p>从上文中的示例可以看到，构建的接口动态代理对象是通过<code>Feign.builder()</code>生成<code>Feign.Builder</code>的构造者对象，然后设置相关的参数，再调用target方法构造的。<code>Feign.Builder</code>的参数包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//拦截器，组装完RequestTemplate，发请求之前的拦截处理RequestTemplate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;RequestInterceptor&gt; requestInterceptors = <span class="keyword">new</span> ArrayList&lt;RequestInterceptor&gt;();</span><br><span class="line"><span class="comment">//日志级别</span></span><br><span class="line">    <span class="keyword">private</span> Logger.Level logLevel = Logger.Level.NONE;</span><br><span class="line"><span class="comment">//契约模型，默认为Contract.Default，用户创建MethodMetadata，用spring cloud就是扩展这个实现springMVC注解</span></span><br><span class="line">    <span class="keyword">private</span> Contract contract = <span class="keyword">new</span> Contract.Default();</span><br><span class="line"><span class="comment">//客户端，默认为Client.Default，可以扩展ApacheHttpClient，OKHttpClient，RibbonClient等</span></span><br><span class="line">    <span class="keyword">private</span> Client client = <span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//重试设置，默认不设置</span></span><br><span class="line">    <span class="keyword">private</span> Retryer retryer = <span class="keyword">new</span> Retryer.Default();</span><br><span class="line"><span class="comment">//日志，可以接入Slf4j</span></span><br><span class="line">    <span class="keyword">private</span> Logger logger = <span class="keyword">new</span> NoOpLogger();</span><br><span class="line"><span class="comment">//编码器，用于body的编码</span></span><br><span class="line">    <span class="keyword">private</span> Encoder encoder = <span class="keyword">new</span> Encoder.Default();</span><br><span class="line"><span class="comment">//解码器，用户response的解码</span></span><br><span class="line">    <span class="keyword">private</span> Decoder decoder = <span class="keyword">new</span> Decoder.Default();</span><br><span class="line"><span class="comment">//用@QueryMap注解的参数编码器</span></span><br><span class="line">    <span class="keyword">private</span> QueryMapEncoder queryMapEncoder = <span class="keyword">new</span> QueryMapEncoder.Default();</span><br><span class="line"><span class="comment">//请求错误解码器</span></span><br><span class="line">    <span class="keyword">private</span> ErrorDecoder errorDecoder = <span class="keyword">new</span> ErrorDecoder.Default();</span><br><span class="line"><span class="comment">//参数配置，主要是超时时间之类的</span></span><br><span class="line">    <span class="keyword">private</span> Options options = <span class="keyword">new</span> Options();</span><br><span class="line"><span class="comment">//动态代理工厂</span></span><br><span class="line">    <span class="keyword">private</span> InvocationHandlerFactory invocationHandlerFactory = <span class="keyword">new</span> InvocationHandlerFactory.Default();</span><br><span class="line"><span class="comment">//是否decode404</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> decode404;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closeAfterDecode = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>这块是一个典型的构造者模式，<code>target</code>方法内部先调用<code>build</code>方法新建一个<code>ReflectFeign</code>对象，然后调用<code>ReflectFeign</code>的<code>newInstance</code>方法创建动态代理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//默认使用HardCodedTarget</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Class&lt;T&gt; apiType, String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target(<span class="keyword">new</span> HardCodedTarget&lt;T&gt;(apiType, url));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">        <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                             logLevel, decode404, closeAfterDecode);</span><br><span class="line">    ParseHandlersByName handlersByName =</span><br><span class="line">        <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,</span><br><span class="line">                                errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">    <span class="comment">//handlersByName将所有参数进行封装，并提供解析接口方法的逻辑</span></span><br><span class="line">    <span class="comment">//invocationHandlerFactory是Builder的属性，默认值是InvocationHandlerFactory.Default,用创建java动态代理的InvocationHandler实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectiveFeign</code>构造函数有三个参数：</p><ul><li><code>ParseHandlersByName</code> 将builder所有参数进行封装，并提供解析接口方法的逻辑</li><li><code>InvocationHandlerFactory</code> java动态代理的<code>InvocationHandler</code>的工厂类，默认值是<code>InvocationHandlerFactory.Default</code></li><li><code>QueryMapEncoder</code>  接口参数注解<code>@QueryMap</code>时，参数的编码器</li></ul><p><code>ReflectiveFeign.newInstance</code>方法创建接口动态代理对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//targetToHandlersByName是构造器传入的ParseHandlersByName对象，根据target对象生成MethodHandler映射</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">//遍历接口所有方法，构建Method-&gt;MethodHandler的映射</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">      <span class="comment">//接口default方法的Handler，这类方法直接调用</span></span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里factory是构造其中传入的，创建InvocationHandler</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  <span class="comment">//java的动态代理</span></span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line">  <span class="comment">//将default方法直接绑定到动态代理上</span></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码主要的逻辑是：</p><ol><li>创建<code>MethodHandler</code>的映射，这里创建的是实现类<code>SynchronousMethodHandler</code></li><li>通过<code>InvocationHandlerFatory</code>创建<code>InvocationHandler</code></li><li>绑定接口的<code>default</code>方法，通过<code>DefaultMethodHandler</code>绑定</li></ol><p>类图中已经画出，<code>SynchronousMethodHandler</code>和<code>DefaultMethodHandler</code>实现了<code>InvocationHandlerFactory.MethodHandler</code>接口，动态代理对象调用方法时，如果是<code>default</code>方法，会直接调用接口方法，因为这里将接口的<code>default</code>方法绑定到动态代理对象上了，其他方法根据方法签名找到<code>SynchronousMethodHandler</code>对象，调用其<code>invoke</code>方法。</p><h2 id="创建MethodHandler方法处理器"><a href="#创建MethodHandler方法处理器" class="headerlink" title="创建MethodHandler方法处理器"></a>创建MethodHandler方法处理器</h2><p><code>SynchronousMethodHandler</code>是feign组件的核心，接口方法调用转换为http请求和解析http响应都是通过<code>SynchronousMethodHandler</code>来执行的，相关类图如下：</p><p><img src="/images/feign/init2.png" alt=""></p><p>创建<code>MethodHandler</code>实现类<code>SynchronousMethodHandler</code>的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过contract解析接口方法，生成MethodMetadata列表，默认的contract解析Feign自定义的http注解</span></span><br><span class="line">  List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">  Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">    <span class="comment">//BuildTemplateByResolvingArgs实现RequestTemplate.Factory，RequestTemplate的工厂</span></span><br><span class="line">    BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">    <span class="comment">//根据方法元数据，使用不同的RequestTemplate的工厂</span></span><br><span class="line">    <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果有formParam，并且bodyTemplate不为空，请求体为x-www-form-urlencoded格式</span></span><br><span class="line">      <span class="comment">//将会解析form参数，填充到bodyTemplate中</span></span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果包含请求体，将会用encoder编码请求体对象</span></span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//默认的RequestTemplate的工厂，没有请求体，不需要编码器</span></span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md, queryMapEncoder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用工厂SynchronousMethodHandler.Factory创建SynchronousMethodHandler</span></span><br><span class="line">    result.put(md.configKey(),</span><br><span class="line">               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的逻辑是：</p><ol><li>通过<code>Contract</code>解析接口方法，生成<code>MethodMetadata</code>，默认的<code>Contract</code>解析Feign自定义的http注解</li><li>根据<code>MethodMetadata</code>方法元数据生成特定的<code>RequestTemplate</code>的工厂</li><li>使用<code>SynchronousMethodHandler.Factory</code>工厂创建<code>SynchronousMethodHandler</code><br>这里有两个工厂不要搞混淆了，<code>SynchronousMethodHandler</code>工厂和<code>RequestTemplate</code>工厂，<code>SynchronousMethodHandler</code>的属性包含<code>RequestTemplate</code>工厂</li></ol><h2 id="Contract解析接口方法生成MethodMetadata"><a href="#Contract解析接口方法生成MethodMetadata" class="headerlink" title="Contract解析接口方法生成MethodMetadata"></a><code>Contract</code>解析接口方法生成<code>MethodMetadata</code></h2><p>feign默认的解析器是<code>Contract.Default</code>继承了<code>Contract.BaseContract</code>，解析生成<code>MethodMetadata</code>方法入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MethodMetadata&gt; <span class="title">parseAndValidatateMetadata</span><span class="params">(Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">  。。。</span><br><span class="line">  Map&lt;String, MethodMetadata&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodMetadata&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Method method : targetType.getMethods()) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    MethodMetadata metadata = parseAndValidateMetadata(targetType, method);</span><br><span class="line">    。。。</span><br><span class="line">    result.put(metadata.configKey(), metadata);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;MethodMetadata&gt;(result.values());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MethodMetadata <span class="title">parseAndValidateMetadata</span><span class="params">(Class&lt;?&gt; targetType, Method method)</span> </span>&#123;</span><br><span class="line">  MethodMetadata data = <span class="keyword">new</span> MethodMetadata();</span><br><span class="line">  data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));</span><br><span class="line">  data.configKey(Feign.configKey(targetType, method));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(targetType.getInterfaces().length == <span class="number">1</span>) &#123;</span><br><span class="line">    processAnnotationOnClass(data, targetType.getInterfaces()[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理Class上的注解</span></span><br><span class="line">  processAnnotationOnClass(data, targetType);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) &#123;</span><br><span class="line">    <span class="comment">//处理方法注解</span></span><br><span class="line">    processAnnotationOnMethod(data, methodAnnotation, method);</span><br><span class="line">  &#125;</span><br><span class="line">  。。。</span><br><span class="line">  Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">  Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">//方法参数注解</span></span><br><span class="line">  Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">int</span> count = parameterAnnotations.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameterAnnotations[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">      isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes[i] == URI.class) &#123;</span><br><span class="line">      <span class="comment">//参数类型是URI，后面构造http请求时，使用该URI</span></span><br><span class="line">      data.urlIndex(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isHttpAnnotation) &#123;</span><br><span class="line">      <span class="comment">//如果没有被http注解，就是body参数</span></span><br><span class="line">      。。。</span><br><span class="line">      data.bodyIndex(i);</span><br><span class="line">      data.bodyType(Types.resolve(targetType, targetType, genericParameterTypes[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.headerMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//@HeaderMap注解的参数必须是Map，key类型必须是String</span></span><br><span class="line">    checkMapString(<span class="string">"HeaderMap"</span>, parameterTypes[data.headerMapIndex()], genericParameterTypes[data.headerMapIndex()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.queryMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Map.class.isAssignableFrom(parameterTypes[data.queryMapIndex()])) &#123;</span><br><span class="line">      <span class="comment">//@QueryMap注解的参数如果是Map，key类型必须是String</span></span><br><span class="line">      checkMapKeys(<span class="string">"QueryMap"</span>, genericParameterTypes[data.queryMapIndex()]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnClass</span><span class="params">(MethodMetadata data, Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (targetType.isAnnotationPresent(Headers.class)) &#123;</span><br><span class="line">    <span class="comment">//被Headers注解</span></span><br><span class="line">    String[] headersOnType = targetType.getAnnotation(Headers.class).value();</span><br><span class="line">    。。。</span><br><span class="line">    <span class="comment">//header解析成map，加到MethodMetadata中</span></span><br><span class="line">    Map&lt;String, Collection&lt;String&gt;&gt; headers = toMap(headersOnType);</span><br><span class="line">    headers.putAll(data.template().headers());</span><br><span class="line">    data.template().headers(<span class="keyword">null</span>); <span class="comment">// to clear</span></span><br><span class="line">    data.template().headers(headers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata data, Annotation methodAnnotation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Method method)</span> </span>&#123;</span><br><span class="line">  Class&lt;? extends Annotation&gt; annotationType = methodAnnotation.annotationType();</span><br><span class="line">  <span class="keyword">if</span> (annotationType == RequestLine.class) &#123;</span><br><span class="line">    <span class="comment">//@RequestLine注解</span></span><br><span class="line">    String requestLine = RequestLine.class.cast(methodAnnotation).value();</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (requestLine.indexOf(<span class="string">' '</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">      。。。</span><br><span class="line">      data.template().method(requestLine);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//http请求方法</span></span><br><span class="line">    data.template().method(requestLine.substring(<span class="number">0</span>, requestLine.indexOf(<span class="string">' '</span>)));</span><br><span class="line">    <span class="keyword">if</span> (requestLine.indexOf(<span class="string">' '</span>) == requestLine.lastIndexOf(<span class="string">' '</span>)) &#123;</span><br><span class="line">      <span class="comment">// no HTTP version is ok</span></span><br><span class="line">      data.template().append(requestLine.substring(requestLine.indexOf(<span class="string">' '</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// skip HTTP version</span></span><br><span class="line">      data.template().append(</span><br><span class="line">          requestLine.substring(requestLine.indexOf(<span class="string">' '</span>) + <span class="number">1</span>, requestLine.lastIndexOf(<span class="string">' '</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将'%2F'反转为'/'</span></span><br><span class="line">    data.template().decodeSlash(RequestLine.class.cast(methodAnnotation).decodeSlash());</span><br><span class="line">    <span class="comment">//参数集合格式化方式，默认使用key=value0&amp;key=value1</span></span><br><span class="line">    data.template().collectionFormat(RequestLine.class.cast(methodAnnotation).collectionFormat());</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == Body.class) &#123;</span><br><span class="line">    <span class="comment">//@Body注解</span></span><br><span class="line">    String body = Body.class.cast(methodAnnotation).value();</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (body.indexOf(<span class="string">'&#123;'</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//body中不存在&#123;，直接传入body</span></span><br><span class="line">      data.template().body(body);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//body中存在&#123;，就是bodyTemplate方式</span></span><br><span class="line">      data.template().bodyTemplate(body);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == Headers.class) &#123;</span><br><span class="line">    <span class="comment">//@Header注解</span></span><br><span class="line">    String[] headersOnMethod = Headers.class.cast(methodAnnotation).value();</span><br><span class="line">    。。。</span><br><span class="line">    data.template().headers(toMap(headersOnMethod));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理参数上的注解</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processAnnotationsOnParameter</span><span class="params">(MethodMetadata data, Annotation[] annotations, <span class="keyword">int</span> paramIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();</span><br><span class="line">    <span class="keyword">if</span> (annotationType == Param.class) &#123;</span><br><span class="line">      <span class="comment">//@Param注解</span></span><br><span class="line">      Param paramAnnotation = (Param) annotation;</span><br><span class="line">      String name = paramAnnotation.value();</span><br><span class="line">      。。。</span><br><span class="line">      <span class="comment">//增加到MethodMetadata中</span></span><br><span class="line">      nameParam(data, name, paramIndex);</span><br><span class="line">      <span class="comment">//@Param注解的expander参数，定义参数的解释器，默认是ToStringExpander，调用参数的toString方法</span></span><br><span class="line">      Class&lt;? extends Param.Expander&gt; expander = paramAnnotation.expander();</span><br><span class="line">      <span class="keyword">if</span> (expander != Param.ToStringExpander.class) &#123;</span><br><span class="line">        data.indexToExpanderClass().put(paramIndex, expander);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//参数是否已经urlEncoded，如果没有，会使用urlEncoded方式编码</span></span><br><span class="line">      data.indexToEncoded().put(paramIndex, paramAnnotation.encoded());</span><br><span class="line">      isHttpAnnotation = <span class="keyword">true</span>;</span><br><span class="line">      String varName = <span class="string">'&#123;'</span> + name + <span class="string">'&#125;'</span>;</span><br><span class="line">      <span class="keyword">if</span> (!data.template().url().contains(varName) &amp;&amp;</span><br><span class="line">          !searchMapValuesContainsSubstring(data.template().queries(), varName) &amp;&amp;</span><br><span class="line">          !searchMapValuesContainsSubstring(data.template().headers(), varName)) &#123;</span><br><span class="line">        <span class="comment">//如果参数不在path里面，不在query里面，不在header里面，就设置到formParam中</span></span><br><span class="line">        data.formParams().add(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == QueryMap.class) &#123;</span><br><span class="line">      <span class="comment">//@QueryMap注解，注解参数对象时，将该参数转换为http请求参数格式发送</span></span><br><span class="line">      。。。</span><br><span class="line">      data.queryMapIndex(paramIndex);</span><br><span class="line">      data.queryMapEncoded(QueryMap.class.cast(annotation).encoded());</span><br><span class="line">      isHttpAnnotation = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotationType == HeaderMap.class) &#123;</span><br><span class="line">      <span class="comment">//@HeaderMap注解，注解一个Map类型的参数，放入http header中发送</span></span><br><span class="line">      。。。</span><br><span class="line">      data.headerMapIndex(paramIndex);</span><br><span class="line">      isHttpAnnotation = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isHttpAnnotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码稍微有点多，但是逻辑很清晰，先处理类上的注解，再处理方法上注解，最后处理方法参数注解，把所有注解的情况都处理到就可以了。  </p><p>生成的<code>MethodMetadata</code>的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodMetadata</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//标识方法的key，接口名加方法签名：GitHub#contributors(String,String)</span></span><br><span class="line">  <span class="keyword">private</span> String configKey;</span><br><span class="line"><span class="comment">//方法返回值类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Type returnType;</span><br><span class="line"><span class="comment">//uri参数的位置，方法中可以写个uri参数，发请求时直接使用这个参数</span></span><br><span class="line">  <span class="keyword">private</span> Integer urlIndex;</span><br><span class="line"><span class="comment">//body参数的位置，只能有一个未注解的参数为body，否则报错</span></span><br><span class="line">  <span class="keyword">private</span> Integer bodyIndex;</span><br><span class="line"><span class="comment">//headerMap参数的位置</span></span><br><span class="line">  <span class="keyword">private</span> Integer headerMapIndex;</span><br><span class="line"><span class="comment">//@QueryMap注解参数位置</span></span><br><span class="line">  <span class="keyword">private</span> Integer queryMapIndex;</span><br><span class="line"><span class="comment">//@QueryMap注解里面encode参数，是否已经urlEncode编码过了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> queryMapEncoded;</span><br><span class="line"><span class="comment">//body的类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Type bodyType;</span><br><span class="line"><span class="comment">//RequestTemplate 原型</span></span><br><span class="line">  <span class="keyword">private</span> RequestTemplate template = <span class="keyword">new</span> RequestTemplate();</span><br><span class="line"><span class="comment">//form请求参数</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; formParams = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//方法参数位置和名称的map</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Collection&lt;String&gt;&gt; indexToName ;</span><br><span class="line"><span class="comment">//@Param中注解的expander方法，可以指定解析参数类</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Class&lt;? extends Expander&gt;&gt; indexToExpanderClass ;</span><br><span class="line"><span class="comment">//参数是否被urlEncode编码过了，@Param中encoded方法</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Boolean&gt; indexToEncoded ;</span><br><span class="line"><span class="comment">//自定义的Expander</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;Integer, Expander&gt; indexToExpander;</span><br></pre></td></tr></table></figure><blockquote><p><code>Contract也</code>是feign的一个扩展点，一个优秀组件的架构通常是具有很强的扩展性，feign的架构本身很简单，设计的扩展点也很简单方便，所以受到spring的青睐，将其集成到spring cloud中。spring cloud就是通过<code>Contract</code>的扩展，实现使用springMVC的注解接入feign。feign自己还实现了使用jaxrs注解接入feign。</p></blockquote><h2 id="初始化总结"><a href="#初始化总结" class="headerlink" title="初始化总结"></a>初始化总结</h2><p>上文已经完成了feign初始化结构为动态代理的整个过程，简单的捋一遍：</p><ol><li>初始化<code>Feign.Builder</code>传入参数，构造<code>ReflectiveFeign</code></li><li><code>ReflectiveFeign</code>通过内部类<code>ParseHandlersByName</code>的<code>Contract</code>属性，解析接口生成<code>MethodMetadata</code></li><li><code>ParseHandlersByName</code>根据<code>MethodMetadata</code>生成<code>RequestTemplate</code>工厂</li><li><code>ParseHandlersByName</code>创建<code>SynchronousMethodHandler</code>，传入<code>MethodMetadata</code>、<code>RequestTemplate</code>工厂和<code>Feign.Builder</code>相关参数</li><li><code>ReflectiveFeign</code>创建<code>FeignInvocationHandler</code>，传入参数<code>SynchronousMethodHandler</code>，绑定<code>DefaultMethodHandler</code><br>6.<code>ReflectiveFeign</code>根据<code>FeignInvocationHandler</code>创建<code>Proxy</code></li></ol><p>关键的几个类是：</p><ul><li><code>ReflectiveFeign</code> 初始化入口</li><li><code>FeignInvocationHandler</code> 实现动态代理的<code>InvocHandler</code></li><li><code>SynchronousMethodHandler</code> 方法处理器，方法调用处理器</li><li><code>MethodMetadata</code> 方法元数据</li></ul><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>为方便理解，分析完feign源码后，我将feign执行过程分成三层，如下图：</p><p><img src="/images/feign/execute.png" alt=""></p><p>三层分别为：</p><ul><li>代理层 动态代理调用层</li><li>转换层 方法转http请求，解码http响应</li><li>网络层 http请求发送</li></ul><p>java动态代理接口方法调用，会调用到<code>InvocaHandler</code>的invoke方法，feign里面实现类是<code>FeignInvocationHandler</code>，invoke代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&gt; dispatch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  。。。</span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法找到<code>MethodHandler</code>，除接口的<code>default</code>方法外，找到的是<code>SynchronousMethodHandler</code>对象，然后调用<code>SynchronousMethodHandlerd.invoke</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">//buildTemplateFromArgs是RequestTemplate工程对象，根据方法参数创建RequestTemplate</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">//重试设置</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行和解码</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      。。。</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">//RequestTemplate转换为Request</span></span><br><span class="line">  Request request = targetRequest(template)</span><br><span class="line">  。。。</span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">      <span class="comment">//如果接口方法返回的是Response类</span></span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//body为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">              response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        <span class="comment">//body不为空，且length&gt;最大缓存值，返回response，但是不能关闭response</span></span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 读取body字节数组，返回response</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="comment">//响应成功</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) &#123;</span><br><span class="line">        <span class="comment">//接口返回void</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//解码response，直接调用decoder解码</span></span><br><span class="line">        Object result = decode(response);</span><br><span class="line">        shouldClose = closeAfterDecode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">      <span class="comment">//404解析</span></span><br><span class="line">      Object result = decode(response);</span><br><span class="line">      shouldClose = closeAfterDecode;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//其他返回码，使用errorDecoder解析，抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//是否需要关闭response，根据Feign.Builder 参数设置是否要关闭流</span></span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程比较简单，生成<code>RquestTemplate</code> -&gt; 转换为<code>Request</code> -&gt; <code>client</code>发请求 -&gt; <code>Decoder</code>解析<code>Response</code></p><h2 id="RquestTemplate构建过程"><a href="#RquestTemplate构建过程" class="headerlink" title="RquestTemplate构建过程"></a><code>RquestTemplate</code>构建过程</h2><p>先看看<code>RequestTemplate</code>的结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//请求参数 ?后面的name=value</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Collection&lt;String&gt;&gt; queries ;</span><br><span class="line"><span class="comment">//请求头</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Collection&lt;String&gt;&gt; headers ;</span><br><span class="line"><span class="comment">//请求方法 GET/POST等</span></span><br><span class="line">  <span class="keyword">private</span> String method;</span><br><span class="line"><span class="comment">//请求路径</span></span><br><span class="line">  <span class="keyword">private</span> StringBuilder url = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//字符集</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Charset charset;</span><br><span class="line"><span class="comment">//请求体</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"><span class="comment">//@Body("%7B\"user_name\": \"&#123;user_name&#125;\", \"password\": \"&#123;password&#125;\"%7D")注解的模板</span></span><br><span class="line">  <span class="keyword">private</span> String bodyTemplate;</span><br><span class="line"><span class="comment">//是否decode削减，将"%2F"反转为"/"</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> decodeSlash = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//集合格式化，分隔符</span></span><br><span class="line">  <span class="keyword">private</span> CollectionFormat collectionFormat = CollectionFormat.EXPLODED;</span><br></pre></td></tr></table></figure></p><p>在<code>SynchronousMethodHandler.invoke</code>方法中生成<code>RequestTemplate</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildTemplateFromArgs是RequestTemplate.Factory实现类</span></span><br><span class="line">RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br></pre></td></tr></table></figure></p><p><code>RequestTemplate.Factory</code>有三个实现类：</p><ul><li><code>BuildTemplateByResolvingArgs</code> <code>RequestTemplate</code>工厂</li><li><code>BuildEncodedTemplateFromArgs</code> <code>BuildTemplateByResolvingArgs</code>的子类 重载<code>resolve</code>方法，解析form表单请求</li><li><code>BuildFormEncodedTemplateFromArgs</code> <code>BuildTemplateByResolvingArgs</code>的子类，重载<code>resolve</code>方法，解析body请求</li></ul><p><code>BuildTemplateByResolvingArgs</code>创建<code>RequestTemplate</code>的<code>create</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BuildTemplateByResolvingArgs实现RequestTemplate.Factory的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestTemplate <span class="title">create</span><span class="params">(Object[] argv)</span> </span>&#123;</span><br><span class="line">  RequestTemplate mutable = <span class="keyword">new</span> RequestTemplate(metadata.template());</span><br><span class="line">  <span class="keyword">if</span> (metadata.urlIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//插入接口方法参数中的URI</span></span><br><span class="line">    <span class="keyword">int</span> urlIndex = metadata.urlIndex();</span><br><span class="line">    mutable.insert(<span class="number">0</span>, String.valueOf(argv[urlIndex]));</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;String, Object&gt; varBuilder = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">  <span class="comment">//方法参数位置和请求定义的参数名称的map</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Integer, Collection&lt;String&gt;&gt; entry : metadata.indexToName().entrySet()) &#123;</span><br><span class="line">    <span class="comment">//将方法参数值和定义的请求参数进行映射，varBuilder</span></span><br><span class="line">    <span class="keyword">int</span> i = entry.getKey();</span><br><span class="line">    Object value = argv[entry.getKey()];</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123; <span class="comment">// Null values are skipped.</span></span><br><span class="line">      <span class="keyword">if</span> (indexToExpander.containsKey(i)) &#123;</span><br><span class="line">        value = expandElements(indexToExpander.get(i), value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String name : entry.getValue()) &#123;</span><br><span class="line">        varBuilder.put(name, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析RequestTemplate</span></span><br><span class="line">  RequestTemplate template = resolve(argv, mutable, varBuilder);</span><br><span class="line">  <span class="comment">//解析queryMap，这块代码有些奇怪，为什么单独把queryMap放在这里解析，而不是在resolve方法中，或者在RequestTemplate中</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.queryMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// add query map parameters after initial resolve so that they take</span></span><br><span class="line">    <span class="comment">// precedence over any predefined values</span></span><br><span class="line">    Object value = argv[metadata.queryMapIndex()];</span><br><span class="line">    Map&lt;String, Object&gt; queryMap = toQueryMap(value);</span><br><span class="line">    template = addQueryMapQueryParameters(queryMap, template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析headerMap定义的参数</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.headerMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    template = addHeaderMapHeaders((Map&lt;String, Object&gt;) argv[metadata.headerMapIndex()], template);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BuildTemplateByResolvingArgs</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestTemplate <span class="title">resolve</span><span class="params">(Object[] argv, RequestTemplate mutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据需要进行urlEncode参数</span></span><br><span class="line">  Map&lt;String, Boolean&gt; variableToEncoded = <span class="keyword">new</span> LinkedHashMap&lt;String, Boolean&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Integer, Boolean&gt; entry : metadata.indexToEncoded().entrySet()) &#123;</span><br><span class="line">    Collection&lt;String&gt; names = metadata.indexToName().get(entry.getKey());</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">      variableToEncoded.put(name, entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析参数</span></span><br><span class="line">  <span class="keyword">return</span> mutable.resolve(variables, variableToEncoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BuildEncodedTemplateFromArgs</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestTemplate <span class="title">resolve</span><span class="params">(Object[] argv, RequestTemplate mutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">  Object body = argv[metadata.bodyIndex()];</span><br><span class="line">  checkArgument(body != <span class="keyword">null</span>, <span class="string">"Body parameter %s was null"</span>, metadata.bodyIndex());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//编码并设置RequestTemplate的body</span></span><br><span class="line">    encoder.encode(body, metadata.bodyType(), mutable);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (EncodeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EncodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.resolve(argv, mutable, variables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BuildFormEncodedTemplateFromArgs</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestTemplate <span class="title">resolve</span><span class="params">(Object[] argv, RequestTemplate mutable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//构造form参数，为HashMap</span></span><br><span class="line">  Map&lt;String, Object&gt; formVariables = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;String, Object&gt; entry : variables.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.formParams().contains(entry.getKey())) &#123;</span><br><span class="line">      formVariables.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//编码并设置RequestTemplate的body，</span></span><br><span class="line">    encoder.encode(formVariables, Encoder.MAP_STRING_WILDCARD, mutable);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (EncodeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EncodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用父类的resolve</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.resolve(argv, mutable, variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>RequestTemplate</code>解析参数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestTemplate解析参数的方法</span></span><br><span class="line"><span class="function">RequestTemplate <span class="title">resolve</span><span class="params">(Map&lt;String, ?&gt; unencoded, Map&lt;String, Boolean&gt; alreadyEncoded)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//替换请求Query中的参数</span></span><br><span class="line">  replaceQueryValues(unencoded, alreadyEncoded);</span><br><span class="line">  Map&lt;String, String&gt; encoded = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;String, ?&gt; entry : unencoded.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">final</span> String key = entry.getKey();</span><br><span class="line">    <span class="keyword">final</span> Object objectValue = entry.getValue();</span><br><span class="line">    String encodedValue = encodeValueIfNotEncoded(key, objectValue, alreadyEncoded);</span><br><span class="line">    encoded.put(key, encodedValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析Url，替换path中的参数</span></span><br><span class="line">  String resolvedUrl = expand(url.toString(), encoded).replace(<span class="string">"+"</span>, <span class="string">"%20"</span>);</span><br><span class="line">  <span class="keyword">if</span> (decodeSlash) &#123;</span><br><span class="line">    resolvedUrl = resolvedUrl.replace(<span class="string">"%2F"</span>, <span class="string">"/"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  url = <span class="keyword">new</span> StringBuilder(resolvedUrl);</span><br><span class="line">  <span class="comment">//解析http请求的header</span></span><br><span class="line">  Map&lt;String, Collection&lt;String&gt;&gt; resolvedHeaders = <span class="keyword">new</span> LinkedHashMap&lt;String, Collection&lt;String&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String field : headers.keySet()) &#123;</span><br><span class="line">    Collection&lt;String&gt; resolvedValues = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String value : valuesOrEmpty(headers, field)) &#123;</span><br><span class="line">      String resolved = expand(value, unencoded);</span><br><span class="line">      resolvedValues.add(resolved);</span><br><span class="line">    &#125;</span><br><span class="line">    resolvedHeaders.put(field, resolvedValues);</span><br><span class="line">  &#125;</span><br><span class="line">  headers.clear();</span><br><span class="line">  headers.putAll(resolvedHeaders);</span><br><span class="line">  <span class="comment">//处理bodyTemplate</span></span><br><span class="line">  <span class="keyword">if</span> (bodyTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    body(urlDecode(expand(bodyTemplate, encoded)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工具方法，将含有&#123;varName&#125;的字符串模板中的变量名用变量值替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">expand</span><span class="params">(String template, Map&lt;String, ?&gt; variables)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (checkNotNull(template, <span class="string">"template"</span>).length() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line">  checkNotNull(variables, <span class="string">"variables for %s"</span>, template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> inVar = <span class="keyword">false</span>;</span><br><span class="line">  StringBuilder var = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c : template.toCharArray()) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">        <span class="keyword">if</span> (inVar) &#123;</span><br><span class="line">          <span class="comment">// '&#123;&#123;' is an escape: write the brace and don't interpret as a variable</span></span><br><span class="line">          builder.append(<span class="string">"&#123;"</span>);</span><br><span class="line">          inVar = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inVar = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">        <span class="keyword">if</span> (!inVar) &#123; <span class="comment">// then write the brace literally</span></span><br><span class="line">          builder.append(<span class="string">'&#125;'</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inVar = <span class="keyword">false</span>;</span><br><span class="line">        String key = var.toString();</span><br><span class="line">        Object value = variables.get(var.toString());</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">          builder.append(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          builder.append(<span class="string">'&#123;'</span>).append(key).append(<span class="string">'&#125;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        var = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (inVar) &#123;</span><br><span class="line">          var.append(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          builder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="RquestTemplate转换Request"><a href="#RquestTemplate转换Request" class="headerlink" title="RquestTemplate转换Request"></a><code>RquestTemplate</code>转换<code>Request</code></h2><p>先来看看<code>Request</code>的结构，完整的http请求信息的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Collection&lt;String&gt;&gt; headers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br></pre></td></tr></table></figure><p><code>SynchronousMethodHandler</code>的<code>targetRequest</code>方法将<code>RequestTemplate</code>转换为<code>Request</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">targetRequest</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先应用所用拦截器，拦截器是在Feign.Builder中传入的，拦截器可以修改RequestTemplate信息</span></span><br><span class="line">  <span class="keyword">for</span> (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用Target的apply方法，默认Target是HardCodedTarget</span></span><br><span class="line">  <span class="keyword">return</span> target.apply(<span class="keyword">new</span> RequestTemplate(template));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这块先应用所有拦截器，然后target的<code>apply</code>方法。拦截器和target都是扩展点，拦截器可以在构造好<code>RequestTemplate</code>后和发请求前修改请求信息，target默认使用<code>HardCodedTarget</code>直接发请求，feign还提供了<code>LoadBalancingTarget</code>，适配Ribbon来发请求，实现客户端的负载均衡。  </p><p>创建过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//HardCodedTarget的apply方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Request <span class="title">apply</span><span class="params">(RequestTemplate input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.url().indexOf(<span class="string">"http"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      input.insert(<span class="number">0</span>, url());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用RequestTemplate的request方法</span></span><br><span class="line">    <span class="keyword">return</span> input.request();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//RequestTemplate的request方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//安全拷贝所有header</span></span><br><span class="line">  Map&lt;String, Collection&lt;String&gt;&gt; safeCopy = <span class="keyword">new</span> LinkedHashMap&lt;String, Collection&lt;String&gt;&gt;();</span><br><span class="line">  safeCopy.putAll(headers);</span><br><span class="line">  <span class="comment">//调用Request的create静态方法</span></span><br><span class="line">  <span class="keyword">return</span> Request.create(</span><br><span class="line">      method, url + queryLine(),</span><br><span class="line">      Collections.unmodifiableMap(safeCopy),</span><br><span class="line">      body, charset</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Request的create方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title">create</span><span class="params">(String method, String url, Map&lt;String, Collection&lt;String&gt;&gt; headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span>[] body, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Request(method, url, headers, body, charset);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>从代码上可以看到，<code>RequestTemplate</code>基本上直接转为<code>Request</code>，没有做什么逻辑操作。对比下<code>LoadBalancingTarget</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Request apply(RequestTemplate input) &#123;</span><br><span class="line">  //选取一个Server，lb是Ribbon的AbstractLoadBalancer类</span><br><span class="line">  Server currentServer = lb.chooseServer(null);</span><br><span class="line">  //生成url</span><br><span class="line">  String url = format(&quot;%s://%s%s&quot;, scheme, currentServer.getHostPort(), path);</span><br><span class="line">  input.insert(0, url);</span><br><span class="line">  try &#123;</span><br><span class="line">    //生成Request</span><br><span class="line">    return input.request();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    lb.getLoadBalancerStats().incrementNumRequests(currentServer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，非常简单的几行代码，只要修改请求的url就能实现客户端负载均衡。</p><h2 id="http请求发送"><a href="#http请求发送" class="headerlink" title="http请求发送"></a>http请求发送</h2><p><code>SynchronousMethodHandler</code>中构造好<code>Request</code>后，直接调用client的<code>execute</code>方法发送请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = client.execute(request, options);</span><br></pre></td></tr></table></figure><p>client是一个<code>Client</code>接口，默认实现类是<code>Client.Default</code>，使用java api中的<code>HttpURLConnection</code>发送http请求。feign还实现了：</p><ul><li><code>ApacheHttpClient</code></li><li><code>OkHttpClient</code></li><li><code>RibbonClient</code><br>使用<code>RibbonClient</code>跟使用<code>LoadBalancingTarget</code>作用都是实现客户端负载均衡，<code>RibbonClient</code>实现稍微复杂些。</li></ul><h2 id="接口调用过程总结"><a href="#接口调用过程总结" class="headerlink" title="接口调用过程总结"></a>接口调用过程总结</h2><p>我们再将接口调用过程捋一遍：</p><p>1、接口的动态代理<code>Proxy</code>调用接口方法会执行的<code>FeignInvocationHandler</code><br>2、<code>FeignInvocationHandler</code>通过方法签名在属性<code>Map&lt;Method, MethodHandler&gt; dispatch</code>中找到<code>SynchronousMethodHandler</code>，调用<code>invoke</code>方法<br>3、<code>SynchronousMethodHandler</code>的<code>invoke</code>方法根据传入的方法参数，通过自身属性工厂对象<code>RequestTemplate.Factory</code>创建<code>RequestTemplate</code>，工厂里面会用根据需要进行<code>Encode</code><br>4、<code>SynchronousMethodHandler</code>遍历自身属性<code>RequestInterceptor</code>列表，对<code>RequestTemplate</code>进行改造<br>4、<code>SynchronousMethodHandler</code>调用自身<code>Target</code>属性的<code>apply</code>方法，将<code>RequestTemplate</code>转换为<code>Request</code>对象<br>5、<code>SynchronousMethodHandler</code>调用自身<code>Client</code>的<code>execute</code>方法，传入<code>Request</code>对象<br>6、<code>Client</code>将<code>Request</code>转换为<code>http</code>请求，发送后将http响应转换为<code>Response</code>对象<br>7、<code>SynchronousMethodHandler</code>调用<code>Decoder</code>的方法对<code>Response</code>对象解码后返回<br>8、返回的对象最后返回到<code>Proxy</code></p><p>时序图如下：<br><img src="/images/feign/execute-sequence.png" alt=""></p><h2 id="feign扩展点总结"><a href="#feign扩展点总结" class="headerlink" title="feign扩展点总结"></a>feign扩展点总结</h2><p>前文分析源代码时，已经提到了feign的扩展点，最后我们再将feign的主要扩展点进行总结一下：</p><ul><li><p><code>Contract</code> 契约<br><code>Contract</code>的作用是解析接口方法，生成Rest定义。feign默认使用自己的定义的注解，还提供了</p><ul><li><code>JAXRSContract</code> javax.ws.rs注解接口实现<br><code>SpringContract</code>是spring cloud提供SpringMVC注解实现方式。</li></ul></li><li><p><code>InvocationHandler</code> 动态代理handler<br>通过<code>InvocationHandlerFactory</code>注入到<code>Feign.Builder</code>中，feign提供了Hystrix的扩展，实现Hystrix接入</p></li><li><p><code>Encoder</code> 请求body编码器<br>feign已经提供扩展包含：</p><ul><li>默认编码器，只能处理String和byte[]</li><li>json编码器<code>GsonEncoder</code>、<code>JacksonEncoder</code></li><li>XML编码器<code>JAXBEncoder</code></li></ul></li><li><p><code>Decoder</code> http响应解码器<br>最基本的有：</p><ul><li>json解码器 <code>GsonDecoder</code>、<code>JacksonDecoder</code></li><li>XML解码器 <code>JAXBDecoder</code></li><li>Stream流解码器 <code>StreamDecoder</code></li></ul></li><li><p><code>Target</code> 请求转换器<br>feign提供的实现有：</p><ul><li><code>HardCodedTarget</code> 默认<code>Target</code>，不做任何处理。</li><li><code>LoadBalancingTarget</code> 使用Ribbon进行客户端路由</li></ul></li><li><p><code>Client</code> 发送http请求的客户端<br>feign提供的<code>Client</code>实现有：</p><ul><li><code>Client.Default</code> 默认实现，使用java api的<code>HttpClientConnection</code>发送http请求</li><li><code>ApacheHttpClient</code> 使用apache的Http客户端发送请求</li><li><code>OkHttpClient</code> 使用OKHttp客户端发送请求</li><li><code>RibbonClient</code> 使用Ribbon进行客户端路由</li></ul></li><li><p><code>RequestInterceptor</code> 请求拦截器<br>调用客户端发请求前，修改<code>RequestTemplate</code>，比如为所有请求添加Header就可以用拦截器实现。</p></li><li><p><code>Retryer</code> 重试策略<br>默认的策略是<code>Retryer.Default</code>，包含<code>3</code>个参数：间隔、最大间隔和重试次数，第一次失败重试前会sleep输入的间隔时间的，后面每次重试sleep时间是前一次的<code>1.5</code>倍，超过最大时间或者最大重试次数就失败</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;feign介绍&quot;&gt;&lt;a href=&quot;#feign介绍&quot; class=&quot;headerlink&quot; title=&quot;feign介绍&quot;&gt;&lt;/a&gt;feign介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OpenFeign/feign/&quot;&gt;Feign&lt;/a&gt;是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于&lt;a href=&quot;https://github.com/square/retrofit&quot;&gt;Retrofit&lt;/a&gt;, &lt;a href=&quot;https://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAXRS-2.0&lt;/a&gt;和&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebSocket&lt;/a&gt;。feign在github上有近3K个star，是一款相当优秀的开源组件，虽然相比Retrofit的近30K个star，逊色了太多，但是spring cloud集成了feign，使得feign在java生态中比Retrofit使用的更加广泛。&lt;/p&gt;
&lt;p&gt;feign的基本原理是在接口方法上加注解，定义rest请求，构造出接口的动态代理对象，然后通过调用接口方法就可以发送http请求，并且自动解析http响应为方法返回值，极大的简化了客户端调用rest api的代码。官网的示例如下：&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="https://github.com/along101/categories/spring/"/>
    
    
      <category term="java" scheme="https://github.com/along101/tags/java/"/>
    
      <category term="feign" scheme="https://github.com/along101/tags/feign/"/>
    
      <category term="rest" scheme="https://github.com/along101/tags/rest/"/>
    
  </entry>
  
  <entry>
    <title>微服务动态配置组件netflix archaius</title>
    <link href="https://github.com/along101/2018/05/14/netflix-archaius/"/>
    <id>https://github.com/along101/2018/05/14/netflix-archaius/</id>
    <published>2018-05-14T04:03:13.000Z</published>
    <updated>2018-07-13T08:27:36.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="archaius介绍"><a href="#archaius介绍" class="headerlink" title="archaius介绍"></a>archaius介绍</h1><p>archaius是Netflix公司开源项目之一，基于java的配置管理类库，主要用于多配置存储的动态获取。主要功能是对apache common configuration类库的扩展。在云平台开发中可以将其用作分布式配置管理依赖构件。同时，它有如下一些特性：</p><ul><li>动态获取属性</li><li>高效和线程安全的配置操作</li><li>配置改变时提供回调机制</li><li>可以通过jmx操作配置</li><li>复合配置</li></ul><a id="more"></a><p>官网给出的结构图：<br><img src="/images/archaius/archaius.png" alt=""></p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>对于传统的单体应用，properties等配置文件可以解决配置问题，同时也可以通过maven profile配置来区别各个环境，但在一个几百上千节点的的微服务生态中，如何把每个微服务的配置文件都进行更新，并且很多时候还需要重启服务，是一件无法忍受的事情。<br>对于微服务架构而言，一个通用的配置中心是必不可少的。zookeeper、consul、etcd都可以作为集中的配置中心，但是他们的客户端api不是为配置而编写的，使用到配置场景时，会显得非常的臃肿，Archaius可以与这些配置中心结合，它提供的动态配置api，使用起来非常简单方便。<br>spring cloud的spring-cloud-netflix-core组件中集成了archaius，hystrix使用archaius动态修改各commandKey对应的参数（并发数和超时时间），用简单优雅的代码实现不重启生效配置项。</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>在maven工程中加入依赖的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.netflix.archaius&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;archaius-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.7.4&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>archaius已经发展到2.x版本，但是spring cloud集成的还是0.7.X  </p><p>编写示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    //获取一个Long型的动态配置项，默认值是1000。</span><br><span class="line">    private static DynamicLongProperty timeToWait =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getLongProperty(&quot;lock.waitTime&quot;, 1000);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //设置回调</span><br><span class="line">        timeToWait.addCallback(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;timeToWait callback, new value: &quot; + timeToWait.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        //每秒将timeToWait动态配置值打印到控制台，timeToWait.get()会动态的获取最新的配置</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;timeToWait: &quot; + timeToWait.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>archaius默认读取classpath下的config.properties，所以在resources目录下增加config.properties文件，文件中增加配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.waitTime=4</span><br></pre></td></tr></table></figure><p>然后运行Main，会在控制台打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timeToWait: 4</span><br><span class="line">timeToWait: 4</span><br><span class="line">timeToWait: 4</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p>让main继续运行，修改config.properties配置文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.waitTime=5</span><br></pre></td></tr></table></figure></p><p>重新编译工程，等待1分钟左右，控制台会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeToWait: 4</span><br><span class="line">timeToWait callback, new value: 5</span><br><span class="line">timeToWait: 5</span><br><span class="line">timeToWait: 5</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p>一分钟等得有点长，在启动main时加入VM参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Darchaius.fixedDelayPollingScheduler.delayMills=2000 -Darchaius.fixedDelayPollingScheduler.initialDelayMills=2000</span><br></pre></td></tr></table></figure><p>只要修改config.properties配置文件，两秒后就能生效。</p><h1 id="api说明"><a href="#api说明" class="headerlink" title="api说明"></a>api说明</h1><h2 id="基本类型动态配置"><a href="#基本类型动态配置" class="headerlink" title="基本类型动态配置"></a>基本类型动态配置</h2><ul><li>DynamicFloatProperty</li><li>DynamicDoubleProperty</li><li>DynamicBooleanProperty</li><li>DynamicStringProperty</li><li>DynamicIntProperty</li><li>DynamicLongProperty</li></ul><p>类图如下：<br><img src="/images/archaius/property.png" alt=""></p><p>基本类型的动态配置继承<code>PropertyWrapper</code>类，实现接口<code>Property</code>，方法说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Property&lt;T&gt; &#123;</span><br><span class="line">    //获取动态配置值</span><br><span class="line">    T getValue();</span><br><span class="line">    //获取默认值</span><br><span class="line">    T getDefaultValue();</span><br><span class="line">    //获取配置名</span><br><span class="line">    String getName();</span><br><span class="line">    //获取修改时间戳</span><br><span class="line">    long getChangedTimestamp();</span><br><span class="line">    //增加修改回调</span><br><span class="line">    void addCallback(Runnable callback);</span><br><span class="line">    //删除所有回调</span><br><span class="line">    void removeAllCallbacks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>DynamicPropertyFactory</code>的单例获取配置项实例</p><h2 id="扩展类型动态配置"><a href="#扩展类型动态配置" class="headerlink" title="扩展类型动态配置"></a>扩展类型动态配置</h2><ul><li><p>DynamicStringListProperty<br>可以动态配置String list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//String list</span><br><span class="line">DynamicStringListProperty prop = new DynamicStringListProperty(&quot;test2&quot;, &quot;0|1&quot;, &quot;\\|&quot;);</span><br><span class="line">List&lt;String&gt; list = prop.get();//获取包含&quot;0&quot;,&quot;1&quot;的字符串列表</span><br></pre></td></tr></table></figure></li><li><p>DynamicStringMapProperty<br>可以动态配置String Map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//String map</span><br><span class="line">DynamicStringMapProperty prop = new DynamicStringMapProperty(&quot;test3&quot;, &quot;key1=1,key2=2,key3=3&quot;);</span><br><span class="line">Map&lt;String, String&gt; map = prop.get();</span><br></pre></td></tr></table></figure></li><li><p>DynamicStringSetProperty<br>可以动态配置String set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//String set</span><br><span class="line">DynamicStringSetProperty prop = new DynamicStringSetProperty(&quot;test4&quot;, &quot;a,b,c&quot;);</span><br></pre></td></tr></table></figure></li></ul><p>这几个扩展类型内部有个<code>private DynamicStringProperty delegate;</code>属性，通过解析配置字符串创建需要的类型。</p><h2 id="变更回调"><a href="#变更回调" class="headerlink" title="变更回调"></a>变更回调</h2><p>动态配置项通过<code>addCallback</code>方法增加回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置回调</span><br><span class="line">timeToWait.addCallback(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;timeToWait callback, new value: &quot; + timeToWait.get());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="指定配置源"><a href="#指定配置源" class="headerlink" title="指定配置源"></a>指定配置源</h1><h2 id="指定配置文件名称"><a href="#指定配置文件名称" class="headerlink" title="指定配置文件名称"></a>指定配置文件名称</h2><p>archauis默认配置源是classpath下的config.properties，可以增加VM启动参数<br><code>-Darchaius.configurationSource.defaultFileName=test.properties</code>来修改文件名称</p><h2 id="指定配置url"><a href="#指定配置url" class="headerlink" title="指定配置url"></a>指定配置url</h2><p>通过启动参数：<br><code>-Darchaius.configurationSource.additionalUrls=file:///c:/config.properties,https://raw.githubusercontent.com/along101/spring-boot-test/master/actuator-test/src/main/resources/application.properties</code>指定配置源的url，以逗号分隔。<br>配置多个url相同配置项，后面的配置会覆盖前面的，classpath下配置文件优先级最低。</p><h1 id="spring-boot集成"><a href="#spring-boot集成" class="headerlink" title="spring boot集成"></a>spring boot集成</h1><p>spring bean初始化完成，属性值从配置文件注入之后，如果修改配置文件，属性值是不会修改的。如果我们想在运行过程中动态的获取配置项，我们可以将spring的Environment注入到bean中，在代码逻辑中从Environment中获取配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;</span><br><span class="line">public void someMethod()&#123;</span><br><span class="line">  ...</span><br><span class="line">  String config = environment.getProperty(&quot;someConfig.name&quot;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码显得有些臃肿，并且性能也不高，因为environment是由多个配置源组合起来的。我们使用archaius动态配置就简单很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private DynamicStringProperty someConfig=DynamicPropertyFactory.getInstance().getStringProperty(&quot;someConfig.name&quot;, &quot;default&quot;);</span><br><span class="line">public void someMethod()&#123;</span><br><span class="line">  ...</span><br><span class="line">  String config = someConfig.get();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想参数变更后做些业务操作，archaius非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//某个bean的内部</span><br><span class="line">private DynamicStringProperty someConfig=DynamicPropertyFactory.getInstance().getStringProperty(&quot;someConfig.name&quot;, &quot;default&quot;);</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">public void someMethod()&#123;</span><br><span class="line">  someConfig.addCallback(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;new value: &quot; + someConfig.get());</span><br><span class="line">            //业务代码</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>spring boot中如何集成archaius呢？ spring-cloud-netflix-core自动配置了archaius，集成spring boot，只要加入如下依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-netflix-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.archaius&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;archaius-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>编写测试类TestApplication验证:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class TestApplication &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ArchaiusAutoConfiguration archaiusAutoConfiguration;</span><br><span class="line"></span><br><span class="line">    private static final DynamicStringProperty archaiusTest =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getStringProperty(&quot;archaius.test&quot;, &quot;test1&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;env config: &quot; + env.getProperty(&quot;archaius.test&quot;));</span><br><span class="line">        System.out.println(&quot;archaius config: &quot; + archaiusTest.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在spring boot配置文件中加入配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archaius.test=archaius-test</span><br></pre></td></tr></table></figure></p><p>运行测试类TestApplication，会在控制台打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env config: archaius-test</span><br><span class="line">archaius config: archaius-test</span><br></pre></td></tr></table></figure></p><p>说明archaius从spring 的env中拿到配置了。  </p><p>但是这里有个问题，spring boot本身使用了外部配置，比如集成了apollo，<strong>修改配置，archaius配置项是不生效的</strong>。分析spring-cloud-netflix-core的源代码，里面有个ConfigurableEnvironmentConfiguration继承了apache的AbstractConfiguration，将spring Environment进行了封装，实例化后作为配置源加到archaius的组合配置中，并没有像DynamicURLConfiguration那样进行schedule。   </p><p>我们前面对archaius的源代码进行了详细的分析，可以对此进行改进，让spring更新env时，archaius配置项能感知到。首先增加一个配置源类，实现PolledConfigurationSource接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class SpringEnvConfigurationSource implements PolledConfigurationSource &#123;</span><br><span class="line">    //spring的Environment</span><br><span class="line">    private ConfigurableEnvironment environment;</span><br><span class="line">    private PropertySourcesPropertyResolver resolver;</span><br><span class="line"></span><br><span class="line">    SpringEnvConfigurationSource(ConfigurableEnvironment environment) &#123;</span><br><span class="line">        this.environment = environment;</span><br><span class="line">        this.resolver = new PropertySourcesPropertyResolver(this.environment.getPropertySources());</span><br><span class="line">        this.resolver.setIgnoreUnresolvableNestedPlaceholders(true);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PollResult poll(boolean initial, Object checkPoint) throws Exception &#123;</span><br><span class="line">        log.debug(&quot;archaius config refresh.&quot;);</span><br><span class="line">        //poll是从spring env中拉取配置</span><br><span class="line">        return PollResult.createFull(getProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; getProperties() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; properties = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //spring env 里面也是多个source组合的</span><br><span class="line">        for (Map.Entry&lt;String, PropertySource&lt;?&gt;&gt; entry : getPropertySources().entrySet()) &#123;</span><br><span class="line">            PropertySource&lt;?&gt; source = entry.getValue();</span><br><span class="line">            if (source instanceof EnumerablePropertySource) &#123;</span><br><span class="line">                EnumerablePropertySource&lt;?&gt; enumerable = (EnumerablePropertySource&lt;?&gt;) source;</span><br><span class="line">                for (String name : enumerable.getPropertyNames()) &#123;</span><br><span class="line">                    if (!properties.containsKey(name)) &#123;</span><br><span class="line">                        properties.put(name, resolver.getProperty(name));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //PropertySource也可能是组合的，通过递归获取</span><br><span class="line">    private Map&lt;String, PropertySource&lt;?&gt;&gt; getPropertySources() &#123;</span><br><span class="line">        Map&lt;String, PropertySource&lt;?&gt;&gt; map = new LinkedHashMap&lt;String, PropertySource&lt;?&gt;&gt;();</span><br><span class="line">        MutablePropertySources sources = null;</span><br><span class="line">        if (environment != null) &#123;</span><br><span class="line">            sources = environment.getPropertySources();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sources = new StandardEnvironment().getPropertySources();</span><br><span class="line">        &#125;</span><br><span class="line">        for (PropertySource&lt;?&gt; source : sources) &#123;</span><br><span class="line">            extract(&quot;&quot;, map, source);</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void extract(String root, Map&lt;String, PropertySource&lt;?&gt;&gt; map,</span><br><span class="line">                         PropertySource&lt;?&gt; source) &#123;</span><br><span class="line">        if (source instanceof CompositePropertySource) &#123;</span><br><span class="line">            for (PropertySource&lt;?&gt; nest : ((CompositePropertySource) source)</span><br><span class="line">                    .getPropertySources()) &#123;</span><br><span class="line">                extract(source.getName() + &quot;:&quot;, map, nest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(root + source.getName(), source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码是参考spring-cloud-netflix-core中的ConfigurableEnvironmentConfiguration实现的。<br>然后编写自动配置类代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(&quot;archaius&quot;)</span><br><span class="line">public class ArchaiusConfig implements EnvironmentAware, InitializingBean &#123;</span><br><span class="line">    private static final String CONFIG_NAME = &quot;springEnv&quot;;</span><br><span class="line">    @Setter</span><br><span class="line">    private int pollDelayMillis = 5000;</span><br><span class="line">    @Setter</span><br><span class="line">    private int poolInitialDelayMillis = 5000;</span><br><span class="line">    @Setter</span><br><span class="line">    private boolean pollIgnoreDeletesFromSource = false;</span><br><span class="line"></span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setEnvironment(Environment environment) &#123;</span><br><span class="line">        this.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        SpringEnvConfigurationSource springEnvConfigurationSource = new SpringEnvConfigurationSource((ConfigurableEnvironment) this.environment);</span><br><span class="line">        //新建一个PollingScheduler</span><br><span class="line">        FixedDelayPollingScheduler scheduler = new FixedDelayPollingScheduler(poolInitialDelayMillis, pollDelayMillis, pollIgnoreDeletesFromSource);</span><br><span class="line">        ConcurrentMapConfiguration configuration = new ConcurrentCompositeConfiguration();</span><br><span class="line">        //开始轮询，从SpringEnvConfigurationSource中拉取，archaius内部会比较配置的变化</span><br><span class="line">        scheduler.startPolling(springEnvConfigurationSource, configuration);</span><br><span class="line"></span><br><span class="line">        //初始化archaius，这段代码也是参考spring-cloud-netflix-core的</span><br><span class="line">        if (ConfigurationManager.isConfigurationInstalled()) &#123;</span><br><span class="line">            AbstractConfiguration installedConfiguration = ConfigurationManager.getConfigInstance();</span><br><span class="line">            if (installedConfiguration instanceof ConcurrentCompositeConfiguration) &#123;</span><br><span class="line">                ConcurrentCompositeConfiguration configInstance = (ConcurrentCompositeConfiguration) installedConfiguration;</span><br><span class="line">                if (configInstance.getConfiguration(CONFIG_NAME) == null)</span><br><span class="line">                    configInstance.addConfigurationAtFront(configuration, CONFIG_NAME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ConcurrentCompositeConfiguration concurrentCompositeConfiguration = new ConcurrentCompositeConfiguration();</span><br><span class="line">            concurrentCompositeConfiguration.addConfiguration(configuration, CONFIG_NAME);</span><br><span class="line">            ConfigurationManager.install(concurrentCompositeConfiguration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改启动类进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class TestApplication &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ConfigurableEnvironment env;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ArchaiusAutoConfiguration archaiusAutoConfiguration;</span><br><span class="line"></span><br><span class="line">    private static final DynamicStringProperty archaiusTest =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getStringProperty(&quot;archaius.test&quot;, &quot;test1&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">        Thread.sleep(50000 * 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;env config: &quot; + env.getProperty(&quot;archaius.test&quot;));</span><br><span class="line">        System.out.println(&quot;archaius config: &quot; + archaiusTest.get());</span><br><span class="line">        //给env中增加一个配置源</span><br><span class="line">        MutablePropertySources sources = env.getPropertySources();</span><br><span class="line">        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();</span><br><span class="line">        config.put(&quot;archaius.test&quot;, &quot;map change&quot;);</span><br><span class="line">        //自定义的配置源加到最前面</span><br><span class="line">        sources.addFirst(new MapPropertySource(&quot;myMap&quot;, config));</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        Thread.sleep(2 * 1000);</span><br><span class="line">                        //打印archaius配置项</span><br><span class="line">                        System.out.println(&quot;archaius config: &quot; + archaiusTest.get());</span><br><span class="line">                        i++;</span><br><span class="line">                        //修改配置源</span><br><span class="line">                        config.put(&quot;archaius.test&quot;, &quot;map change &quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">env config: archaius-test</span><br><span class="line">archaius config: archaius-test</span><br><span class="line">...</span><br><span class="line">archaius config: map change</span><br><span class="line">archaius config: map change</span><br><span class="line">archaius config: map change 2</span><br><span class="line">archaius config: map change 2</span><br><span class="line">archaius config: map change 2</span><br><span class="line">archaius config: map change 5</span><br><span class="line">archaius config: map change 5</span><br><span class="line">archaius config: map change 7</span><br><span class="line">archaius config: map change 7</span><br></pre></td></tr></table></figure></p><p>可以看到不是每次修改都会生效，轮询时间在ArchaiusConfig中进行的配置。代码地址：<a href="https://github.com/along101/spring-boot-test/tree/5ad5158732ea363aa4fb5b9b965c08977699a9c6/archaius-test">https://github.com/along101/spring-boot-test/tree/5ad5158732ea363aa4fb5b9b965c08977699a9c6/archaius-test</a></p><p>就这么几十行代码就可以将archaius与spring boot结合起来了。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>archaius源码不多，重点在配置的初始化和动态变更这块。</p><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>初始化入口是<code>DynamicPropertyFactory.getInstance()</code>，来看看该方法源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static DynamicPropertyFactory getInstance() &#123;</span><br><span class="line">    if (config == null) &#123;</span><br><span class="line">        synchronized (ConfigurationManager.class) &#123;</span><br><span class="line">            if (config == null) &#123;</span><br><span class="line">                //先初始化AbstractConfiguration</span><br><span class="line">                AbstractConfiguration configFromManager = ConfigurationManager.getConfigInstance();</span><br><span class="line">                if (configFromManager != null) &#123;</span><br><span class="line">                    //初始化自己</span><br><span class="line">                    initWithConfigurationSource(configFromManager);</span><br><span class="line">                    initializedWithDefaultConfig = !ConfigurationManager.isConfigurationInstalled();</span><br><span class="line">                    logger.info(&quot;DynamicPropertyFactory is initialized with configuration sources: &quot; + configFromManager);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ConfigurationManager</code>的静态代码块中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">    ...省略部分代码</span><br><span class="line"></span><br><span class="line">    //设置部署上下文，会初始化environment、datacenter、applicationId、serverId、region等等，不配置的话，就为空</span><br><span class="line">    setDeploymentContext(new ConfigurationBasedDeploymentContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过一层层调用，调用到<code>createDefaultConfigInstance</code>来创建<code>AbstractConfiguration</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static AbstractConfiguration createDefaultConfigInstance() &#123;</span><br><span class="line">    //新建一个组合配置，配置列表中自带一个ConcurrentMapConfiguration，这个配置是containerConfiguration，容器自己的配置</span><br><span class="line">    ConcurrentCompositeConfiguration config = new ConcurrentCompositeConfiguration();  </span><br><span class="line">    try &#123;</span><br><span class="line">        //增加一个DynamicURLConfiguration，获取默认配置文件url和配置系统属性archaius.configurationSource.additionalUrls得到的url</span><br><span class="line">        //构造函数最后，开启线程定时从url里面更新配置</span><br><span class="line">        DynamicURLConfiguration defaultURLConfig = new DynamicURLConfiguration();</span><br><span class="line">        config.addConfiguration(defaultURLConfig, URL_CONFIG_NAME);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        logger.warn(&quot;Failed to create default dynamic configuration&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!Boolean.getBoolean(DISABLE_DEFAULT_SYS_CONFIG)) &#123;</span><br><span class="line">        //增加SystemConfiguration</span><br><span class="line">        SystemConfiguration sysConfig = new SystemConfiguration();</span><br><span class="line">        config.addConfiguration(sysConfig, SYS_CONFIG_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!Boolean.getBoolean(DISABLE_DEFAULT_ENV_CONFIG)) &#123;</span><br><span class="line">        //增加环境配置</span><br><span class="line">        EnvironmentConfiguration envConfig = new EnvironmentConfiguration();</span><br><span class="line">        config.addConfiguration(envConfig, ENV_CONFIG_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    //增加app的组合配置</span><br><span class="line">    ConcurrentCompositeConfiguration appOverrideConfig = new ConcurrentCompositeConfiguration();</span><br><span class="line">    config.addConfiguration(appOverrideConfig, APPLICATION_PROPERTIES);</span><br><span class="line">    config.setContainerConfigurationIndex(config.getIndexOfConfiguration(appOverrideConfig));</span><br><span class="line">    return config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化完后，得到一个组合配置，包含5个配置，顺序为：</p><ul><li>URL_CONFIG_NAME 通过url拉取的配置</li><li>SYS_CONFIG_NAME 系统属性配置,通过<code>System.getProperties()</code>获取的配置</li><li>ENV_CONFIG_NAME 环境配置,通过<code>System.getenv()</code>获取的配置</li><li>containerConfiguration 容器配置，<code>ConfigurationManager.getConfigInstance().setProperty(key,value)</code>设置的配置</li><li>APPLICATION_PROPERTIES 调用<code>configurationManager.loadAppOverrideProperties</code>设置的配置</li></ul><p><img src="/images/archaius/config.png" alt=""></p><p>这样就生成了<code>AbstractConfiguration</code>，保存在<code>ConfigurationManager.instance</code>静态变量上。  </p><p>回到<code>DynamicPropertyFactory</code>代码里面，生成了<code>AbstractConfiguration configFromManager</code>之后，调用方法<code>initWithConfigurationSource</code>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static DynamicPropertyFactory initWithConfigurationSource(AbstractConfiguration config) &#123;</span><br><span class="line"></span><br><span class="line">        。。。</span><br><span class="line">        //包装config为DynamicPropertySupport</span><br><span class="line">        return initWithConfigurationSource(new ConfigurationBackedDynamicPropertySupportImpl(config));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面会设置<code>setDirect</code>，将<code>DynamicPropertySupport</code>注册到<code>DynamicProperty</code>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void setDirect(DynamicPropertySupport support) &#123;</span><br><span class="line">    synchronized (ConfigurationManager.class) &#123;</span><br><span class="line">        config = support;</span><br><span class="line">        DynamicProperty.registerWithDynamicPropertySupport(support);</span><br><span class="line">        initializedWithDefaultConfig = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicProperty</code>注册<code>DynamicPropertySupport</code>的过程是增加一个<code>DynamicPropertyListener</code>，更新所有的属性，也就是更新他的静态变量<code>ALL_PROPS</code>里面的配置项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static synchronized void initialize(DynamicPropertySupport config) &#123;</span><br><span class="line">    dynamicPropertySupportImpl = config;</span><br><span class="line">    config.addConfigurationListener(new DynamicPropertyListener());</span><br><span class="line">    updateAllProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里就初始化完了。根据以上源代码的分析，我们画出类图如下：</p><p><img src="/images/archaius/init.png" alt=""></p><p>这里最重要的两个类是</p><ul><li><code>ConfigurationManager</code> 静态变量<code>AbstractConfiguration instance为</code>所有配置项信息</li><li><code>DynamicProperty</code> 静态变量<code>DynamicPropertySupport dynamicPropertySupportImpl</code>用于动态更新，静态变量<code>ConcurrentHashMap&lt;String, DynamicProperty&gt; ALL_PROPS</code>为被使用的动态属性</li></ul><h2 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h2><p>通过以下代码获取动态配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DynamicLongProperty timeToWait =</span><br><span class="line">            DynamicPropertyFactory.getInstance().getLongProperty(&quot;lock.waitTime&quot;, 1000);</span><br></pre></td></tr></table></figure></p><p>进入<code>getLongProperty</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public DynamicLongProperty getLongProperty(String propName, long defaultValue, final Runnable propertyChangeCallback) &#123;</span><br><span class="line">    //检查初始化</span><br><span class="line">    checkAndWarn(propName);</span><br><span class="line">    //新建一个动态配置</span><br><span class="line">    DynamicLongProperty property = new DynamicLongProperty(propName, defaultValue);</span><br><span class="line">    //增加回调</span><br><span class="line">    addCallback(propertyChangeCallback, property);</span><br><span class="line">    return property;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DynamicLongProperty</code>继承了<code>PropertyWrapper</code>，含有属性<code>DynamicProperty prop</code>，先初始化该属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.prop = DynamicProperty.getInstance(propName);</span><br></pre></td></tr></table></figure></p><p>再往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static DynamicProperty getInstance(String propName) &#123;</span><br><span class="line">    //dynamicPropertySupportImpl为空，先初始化DynamicPropertyFactory</span><br><span class="line">    if (dynamicPropertySupportImpl == null) &#123;</span><br><span class="line">        DynamicPropertyFactory.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    //从ALL_PROPS中获取prop，没有的话，新建，并放到ALL_PROPS中</span><br><span class="line">    //这里没有加同步设置，但是做了个小动作，没有并发问题</span><br><span class="line">    DynamicProperty prop = ALL_PROPS.get(propName);</span><br><span class="line">    if (prop == null) &#123;</span><br><span class="line">        prop = new DynamicProperty(propName);</span><br><span class="line">        //ALL_PROPS是ConcurrentHashMap，putIfAbsent是线程安全的，存在的话返回老的值</span><br><span class="line">        DynamicProperty oldProp = ALL_PROPS.putIfAbsent(propName, prop);</span><br><span class="line">        //oldProp不为null，返回oldProp，解决了并发的问题，副作用是多建了DynamicProperty对象</span><br><span class="line">        if (oldProp != null) &#123;</span><br><span class="line">            prop = oldProp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看<code>new DynamicProperty(propName)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    private DynamicProperty(String propName) &#123;</span><br><span class="line">        //设置属性名称</span><br><span class="line">        this.propName = propName;</span><br><span class="line">        updateValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//更新属性值</span><br><span class="line">private boolean updateValue() &#123;</span><br><span class="line">        String newValue;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (dynamicPropertySupportImpl != null) &#123;</span><br><span class="line">                //从dynamicPropertySupportImpl中获取配置项，这里是包装AbstractConfiguration的，也就是在ConfigurationManager中的instance</span><br><span class="line">                newValue = dynamicPropertySupportImpl.getString(propName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;Unable to update property: &quot; + propName, e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return updateValue(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">boolean updateValue(Object newValue) &#123;</span><br><span class="line">        String nv = (newValue == null) ? null : newValue.toString();</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            if ((nv == null &amp;&amp; stringValue == null)</span><br><span class="line">               || (nv != null &amp;&amp; nv.equals(stringValue))) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //更新stringValue</span><br><span class="line">            stringValue = nv;</span><br><span class="line">            //刷新缓存</span><br><span class="line">            cachedStringValue.flush();</span><br><span class="line">            booleanValue.flush();</span><br><span class="line">            integerValue.flush();</span><br><span class="line">            floatValue.flush();</span><br><span class="line">            classValue.flush();</span><br><span class="line">            doubleValue.flush();</span><br><span class="line">            longValue.flush();</span><br><span class="line">            changedTime = System.currentTimeMillis();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里<code>DynamicLongProperty</code>对象就新建了，里面包含一个<code>DynamicProperty</code>，配置值的更新、回调都是由这个<code>DynamicProperty</code>完成的，他的属性有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//配置名称</span><br><span class="line">private String propName;</span><br><span class="line">//配置的值，原始string</span><br><span class="line">private String stringValue = null;</span><br><span class="line">//更新时间</span><br><span class="line">private long changedTime;</span><br><span class="line">//回到函数表</span><br><span class="line">private CopyOnWriteArraySet&lt;Runnable&gt; callbacks = new CopyOnWriteArraySet&lt;Runnable&gt;();</span><br><span class="line"></span><br><span class="line">//缓存的StringValue</span><br><span class="line">private CachedValue&lt;String&gt; cachedStringValue = new CachedValue&lt;String&gt;() &#123;</span><br><span class="line">    protected String parse(String rep) &#123;</span><br><span class="line">        return rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//缓存的integerValue</span><br><span class="line">private CachedValue&lt;Integer&gt; integerValue = new CachedValue&lt;Integer&gt;() &#123;</span><br><span class="line">    protected Integer parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Integer.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Long&gt; longValue = new CachedValue&lt;Long&gt;() &#123;</span><br><span class="line">    protected Long parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Long.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Float&gt; floatValue = new CachedValue&lt;Float&gt;() &#123;</span><br><span class="line">    protected Float parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Float.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Double&gt; doubleValue = new CachedValue&lt;Double&gt;() &#123;</span><br><span class="line">    protected Double parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Double.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private CachedValue&lt;Class&gt; classValue = new CachedValue&lt;Class&gt;() &#123;</span><br><span class="line">    protected Class parse(String rep) throws ClassNotFoundException &#123;</span><br><span class="line">        return Class.forName(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>CachedValue</code>是<code>DynamicLongProperty</code>的内部类，缓存了配置的实际值，通过解析<code>DynamicLongProperty</code>的stringValue值获取不同类型的配置值。下面我们来分析这一过程。<code>DynamicLongProperty.get()</code>获取动态配置项的值代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long get() &#123;</span><br><span class="line">    return prop.getLong(defaultValue).longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过内置的prop属性即<code>DynamicProperty</code>获取的配置项，prop中通过属性longValue获取配置项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Long getLong(Long defaultValue) &#123;</span><br><span class="line">    return longValue.getValue(defaultValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面初始化prop时，会初始化属性<code>CachedValue&lt;Long&gt; longValue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private CachedValue&lt;Long&gt; longValue = new CachedValue&lt;Long&gt;() &#123;</span><br><span class="line">    protected Long parse(String rep) throws NumberFormatException &#123;</span><br><span class="line">        return Long.valueOf(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>longValue是一个<code>CachedValue</code>类型，getValue方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public T getValue() throws IllegalArgumentException &#123;</span><br><span class="line">    // Not quite double-check locking -- since isCached is marked as volatile</span><br><span class="line">    if (!isCached) &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //如果配置值DynamicProperty.stringValue为null，则没有该配置项，返回null，否则解析stringValue返回</span><br><span class="line">                //这里的parse方法自然是调用longValue的parse方法返回Long值</span><br><span class="line">                value = (stringValue == null) ? null : parse(stringValue);</span><br><span class="line">                exception = null;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                value = null;</span><br><span class="line">                exception = new IllegalArgumentException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                isCached = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exception != null) &#123;</span><br><span class="line">        throw exception;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，通过<code>DynamicLongProperty.getLongProperty</code>获取的配置值就能拿到了。其他的<code>DynamicIntProperty</code>、<code>DynamicStringProperty</code>等配置项的获取与此相同。</p><h2 id="动态更新"><a href="#动态更新" class="headerlink" title="动态更新"></a>动态更新</h2><p>archaius最有价值的特点是能动态更新配置项，这里动态更新的配置项是指前面我们分析初始化是的<code>DynamicURLConfiguration</code>，我们先看看<code>DynamicURLConfiguration</code>的是如何动态更新的，构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public DynamicURLConfiguration() &#123;</span><br><span class="line">    URLConfigurationSource source = new URLConfigurationSource();</span><br><span class="line">    if (source.getConfigUrls() != null &amp;&amp; source.getConfigUrls().size() &gt; 0) &#123;</span><br><span class="line">        startPolling(source, new FixedDelayPollingScheduler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的startPolling开始轮询url资源内容，然后更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void startPolling(PolledConfigurationSource source, AbstractPollingScheduler scheduler) &#123;</span><br><span class="line">    this.scheduler = scheduler;</span><br><span class="line">    this.source = source;</span><br><span class="line">    init(source, scheduler);</span><br><span class="line">    //然后schedule调度轮询</span><br><span class="line">    scheduler.startPolling(source, this);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void startPolling(final PolledConfigurationSource source, final Configuration config) &#123;</span><br><span class="line">    //先初始化</span><br><span class="line">    initialLoad(source, config);</span><br><span class="line">    Runnable r = getPollingRunnable(source, config);</span><br><span class="line">    schedule(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected synchronized void schedule(Runnable runnable) &#123;</span><br><span class="line">//线程池调度</span><br><span class="line">    executor = Executors.newScheduledThreadPool(1, new ThreadFactory() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Thread newThread(Runnable r) &#123;</span><br><span class="line">            Thread t = new Thread(r, &quot;pollingConfigurationSource&quot;);</span><br><span class="line">            t.setDaemon(true);</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executor.scheduleWithFixedDelay(runnable, initialDelayMillis, delayMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Runnable getPollingRunnable(final PolledConfigurationSource source, final Configuration config) &#123;</span><br><span class="line">    return new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.debug(&quot;Polling started&quot;);</span><br><span class="line">            PollResult result = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                //重点是这里，拉取配置结果</span><br><span class="line">                result = source.poll(false, getNextCheckPoint(checkPoint));</span><br><span class="line">                checkPoint = result.getCheckPoint();</span><br><span class="line">                fireEvent(EventType.POLL_SUCCESS, result, null);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;Error getting result from polling source&quot;, e);</span><br><span class="line">                fireEvent(EventType.POLL_FAILURE, null, e);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                //更新配置</span><br><span class="line">                populateProperties(result, config);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;Error occured applying properties&quot;, e);</span><br><span class="line">            &#125;                 </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是先初始化，从url中拉取配置，然后开启一个线程，间隔一段时间拉取，然后调用populateProperties方法更新配置。<br>source.poll代码比较简单，获取url资源，得到Properties，转换为map，封装在<code>PollResult</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public PollResult poll(boolean initial, Object checkPoint)</span><br><span class="line">        throws IOException &#123;    </span><br><span class="line">    if (configUrls == null || configUrls.length == 0) &#123;</span><br><span class="line">        return PollResult.createFull(null);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    for (URL url: configUrls) &#123;</span><br><span class="line">        InputStream fin = url.openStream();</span><br><span class="line">        Properties props = ConfigurationUtils.loadPropertiesFromInputStream(fin);</span><br><span class="line">        for (Entry&lt;Object, Object&gt; entry: props.entrySet()) &#123;</span><br><span class="line">            map.put((String) entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return PollResult.createFull(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>populateProperties更新配置的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected void populateProperties(final PollResult result, final Configuration config) &#123;</span><br><span class="line">        if (result == null || !result.hasChanges()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!result.isIncremental()) &#123;</span><br><span class="line">            //不是增量结果，即全量结果，默认使用的是全量结果</span><br><span class="line">            Map&lt;String, Object&gt; props = result.getComplete();</span><br><span class="line">            if (props == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //遍历每个配置项，进行更新</span><br><span class="line">            for (Entry&lt;String, Object&gt; entry: props.entrySet()) &#123;</span><br><span class="line">                propertyUpdater.addOrChangeProperty(entry.getKey(), entry.getValue(), config);</span><br><span class="line">            &#125;</span><br><span class="line">            //下面这段逻辑是删除配置项</span><br><span class="line">            HashSet&lt;String&gt; existingKeys = new HashSet&lt;String&gt;();</span><br><span class="line">            for (Iterator&lt;String&gt; i = config.getKeys(); i.hasNext();) &#123;</span><br><span class="line">                existingKeys.add(i.next());</span><br><span class="line">            &#125;</span><br><span class="line">            if (!ignoreDeletesFromSource) &#123;</span><br><span class="line">                for (String key: existingKeys) &#123;</span><br><span class="line">                    if (!props.containsKey(key)) &#123;</span><br><span class="line">                        propertyUpdater.deleteProperty(key, config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //增量结果，默认情况下是全量，一般不会走这里</span><br><span class="line">            。。。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>先遍历所有配置项进行更新，然后处理删除配置项。通过propertyUpdater.addOrChangeProperty更新配置型，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void addOrChangeProperty(final String name, final Object newValue, final Configuration config) &#123;</span><br><span class="line">        // We do not want to abort the operation due to failed validation on one property</span><br><span class="line">        try &#123;</span><br><span class="line">            //config中不包含配置项就增加</span><br><span class="line">            if (!config.containsKey(name)) &#123;</span><br><span class="line">                logger.debug(&quot;adding property key [&#123;&#125;], value [&#123;&#125;]&quot;, name, newValue);</span><br><span class="line"></span><br><span class="line">                config.addProperty(name, newValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //包含的话就比较</span><br><span class="line">                Object oldValue = config.getProperty(name);</span><br><span class="line"></span><br><span class="line">                if (newValue != null) &#123;</span><br><span class="line">                    Object newValueArray;</span><br><span class="line">                    //数组处理</span><br><span class="line">                    if (oldValue instanceof CopyOnWriteArrayList &amp;&amp; AbstractConfiguration.getDefaultListDelimiter() != &apos;\0&apos;)&#123;</span><br><span class="line">                        newValueArray =</span><br><span class="line">                                        new CopyOnWriteArrayList();</span><br><span class="line"></span><br><span class="line">                      Iterable&lt;String&gt; stringiterator = Splitter.on(AbstractConfiguration.getDefaultListDelimiter()).omitEmptyStrings().trimResults().split((String)newValue);</span><br><span class="line">                      for(String s :stringiterator)&#123;</span><br><span class="line">                            ((CopyOnWriteArrayList) newValueArray).add(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          newValueArray = newValue;</span><br><span class="line">                      &#125;</span><br><span class="line">                    //不相同修改配置</span><br><span class="line">                    if (!newValueArray.equals(oldValue)) &#123;</span><br><span class="line">                        logger.debug(&quot;updating property key [&#123;&#125;], value [&#123;&#125;]&quot;, name, newValue);</span><br><span class="line"></span><br><span class="line">                        config.setProperty(name, newValue);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; else if (oldValue != null) &#123;</span><br><span class="line">                    logger.debug(&quot;nulling out property key [&#123;&#125;]&quot;, name);</span><br><span class="line"></span><br><span class="line">                    config.setProperty(name, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ValidationException e) &#123;</span><br><span class="line">            logger.warn(&quot;Validation failed for property &quot; + name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更新配置项的过程是拿出老的配置值跟新的配置值进行比较，不相同才修改，还处理了下数组配置项。这里的config是<code>DynamicURLConfiguration</code>，setProperty方法中触发事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setProperty(String key, Object value) throws ValidationException</span><br><span class="line">&#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Value for property &quot; + key + &quot; is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fireEvent(EVENT_SET_PROPERTY, key, value, true);</span><br><span class="line">    setPropertyImpl(key, value);</span><br><span class="line">    fireEvent(EVENT_SET_PROPERTY, key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setPropertyImpl方法修改<code>DynamicURLConfiguration</code>内部保存的配置项，这里虽然改了<code>DynamicURLConfiguration</code>配置项值，但是真正用到的地方存在<code>DynamicProperty</code>中，触发fireEvent方法才会去修改<code>DynamicProperty</code>中的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void fireEvent(int type, String propName, Object propValue, boolean beforeUpdate) &#123;</span><br><span class="line">    if (listeners == null || listeners.size() == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationEvent event = createEvent(type, propName, propValue, beforeUpdate);</span><br><span class="line">    //通知每个监听器，这里listeners是一个CopyOnWriteArrayList类型，防止在遍历过程中更新数据产生问题</span><br><span class="line">    for (ConfigurationListener l: listeners)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            l.configurationChanged(event);</span><br><span class="line">        &#125; catch (ValidationException e) &#123;</span><br><span class="line">            if (beforeUpdate) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                logger.error(&quot;Unexpected exception&quot;, e);                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            logger.error(&quot;Error firing configuration event&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicURLConfiguration</code>添加到<code>ConcurrentCompositeConfiguration</code>中时，<code>ConcurrentCompositeConfiguration</code>会给每个Configuration增加一个<code>ConfigurationListener eventPropagater</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void addConfigurationAtIndex(AbstractConfiguration config, String name, int index)</span><br><span class="line">    throws IndexOutOfBoundsException &#123;</span><br><span class="line">        if (!configList.contains(config)) &#123;</span><br><span class="line">            checkIndex(index);</span><br><span class="line">            configList.add(index, config);</span><br><span class="line">            if (name != null) &#123;</span><br><span class="line">                namedConfigurations.put(name, config);</span><br><span class="line">            &#125;</span><br><span class="line">            //将自己的属性eventPropagater添加到config的监听列表中</span><br><span class="line">            config.addConfigurationListener(eventPropagater);</span><br><span class="line">            fireEvent(EVENT_CONFIGURATION_SOURCE_CHANGED, null, null, false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.warn(config + &quot; is not added as it already exits&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicURLConfiguration</code>中就有一个<code>ConfigurationListener</code>的监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//ConcurrentCompositeConfiguration监听器属性初始化</span><br><span class="line">private ConfigurationListener eventPropagater = new ConfigurationListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configurationChanged(ConfigurationEvent event) &#123;</span><br><span class="line">        boolean beforeUpdate = event.isBeforeUpdate();</span><br><span class="line">        if (propagateEventToParent) &#123;</span><br><span class="line">            int type = event.getType();</span><br><span class="line">            String name = event.getPropertyName();</span><br><span class="line">            Object value = event.getPropertyValue();</span><br><span class="line">            Object finalValue;</span><br><span class="line">            switch(type) &#123;</span><br><span class="line">            case HierarchicalConfiguration.EVENT_ADD_NODES:</span><br><span class="line">            case EVENT_CLEAR:</span><br><span class="line">            case EVENT_CONFIGURATION_SOURCE_CHANGED:</span><br><span class="line">                fireEvent(type, name, value, beforeUpdate);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case EVENT_ADD_PROPERTY:</span><br><span class="line">            case EVENT_SET_PROPERTY:</span><br><span class="line">                //不管是beforeUpdate是true还是false，都会调用自己的fireEvent方法</span><br><span class="line">                if (beforeUpdate) &#123;</span><br><span class="line">                    // we want the validators to run even if the source is not</span><br><span class="line">                    // the winning configuration</span><br><span class="line">                    fireEvent(type, name, value, beforeUpdate);                                                </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    AbstractConfiguration sourceConfig = (AbstractConfiguration) event.getSource();</span><br><span class="line">                    AbstractConfiguration winningConf = (AbstractConfiguration) getSource(name);</span><br><span class="line">                    if (winningConf == null || getIndexOfConfiguration(sourceConfig) &lt;= getIndexOfConfiguration(winningConf)) &#123;</span><br><span class="line">                        fireEvent(type, name, value, beforeUpdate);                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case EVENT_CLEAR_PROPERTY:</span><br><span class="line">                finalValue = ConcurrentCompositeConfiguration.this.getProperty(name);</span><br><span class="line">                if (finalValue == null) &#123;</span><br><span class="line">                    fireEvent(type, name, value, beforeUpdate);                        </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fireEvent(EVENT_SET_PROPERTY, name, finalValue, beforeUpdate);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，最后都调用<code>ConcurrentCompositeConfiguration</code>的fireEvent方法，fireEvent是从父类继承过来的，作用是调用所有监听器，那么<code>ConcurrentCompositeConfiguration</code>的监听器有哪些呢？我们调试过程中发现有两个：</p><ul><li>ExpandedConfigurationListenerAdapter 配置监听适配器</li><li>ConfigurationBasedDeploymentContext.configListener 部署监听器，环境配置发生改变时，修改环境配置项</li></ul><p>重要的是这个<code>ExpandedConfigurationListenerAdapter</code>，作用是将arhaius定义的监听器适配到Apache定义的监听器上，一个典型的适配器模式。<code>ExpandedConfigurationListenerAdapter</code>含有一个<code>PropertyListener expandedListener</code>属性，实现类是<code>DynamicProperty</code>的内部类<code>DynamicPropertyListener</code>。初始化的地方在<code>DynamicPropertyFactory</code>方法setDirect中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void setDirect(DynamicPropertySupport support) &#123;</span><br><span class="line">    synchronized (ConfigurationManager.class) &#123;</span><br><span class="line">        config = support;</span><br><span class="line">        DynamicProperty.registerWithDynamicPropertySupport(support);</span><br><span class="line">        initializedWithDefaultConfig = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DynamicProperty.registerWithDynamicPropertySupport</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void registerWithDynamicPropertySupport(DynamicPropertySupport config) &#123;</span><br><span class="line">    initialize(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static synchronized void initialize(DynamicPropertySupport config) &#123;</span><br><span class="line">    dynamicPropertySupportImpl = config;</span><br><span class="line">    //这里新建DynamicPropertyListener增加到config中</span><br><span class="line">    config.addConfigurationListener(new DynamicPropertyListener());</span><br><span class="line">    updateAllProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的config实现类是<code>ConfigurationBackedDynamicPropertySupportImpl</code>，同样是一个适配器模式，将apache的<code>DynamicPropertySupport</code>适配为archaius自己的<code>DynamicPropertySupport</code>，在<code>DynamicProperty</code>里面会用到。我们给出类图：</p><p><img src="/images/archaius/listener.png" alt=""></p><p>根据前面的分析，fireEvent触发的事件最终会适配到<code>DynamicPropertyListener</code>的setProperty方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//事件触发中调用setProperty</span><br><span class="line">@Override</span><br><span class="line">public void setProperty(Object source, String name, Object value, boolean beforeUpdate) &#123;</span><br><span class="line">    if (!beforeUpdate) &#123;</span><br><span class="line">        updateProperty(name, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        validate(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//更新配置</span><br><span class="line">private static boolean updateProperty(String propName, Object value) &#123;</span><br><span class="line">    //从ALL_PROPS中找出动态配置，更新value</span><br><span class="line">    DynamicProperty prop = ALL_PROPS.get(propName);</span><br><span class="line">    if (prop != null &amp;&amp; prop.updateValue(value)) &#123;</span><br><span class="line">        //通知回调</span><br><span class="line">        prop.notifyCallbacks();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新stringValue值，然后刷新缓存</span><br><span class="line">boolean updateValue(Object newValue) &#123;</span><br><span class="line">    String nv = (newValue == null) ? null : newValue.toString();</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        if ((nv == null &amp;&amp; stringValue == null)</span><br><span class="line">           || (nv != null &amp;&amp; nv.equals(stringValue))) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        stringValue = nv;</span><br><span class="line">        cachedStringValue.flush();</span><br><span class="line">        booleanValue.flush();</span><br><span class="line">        integerValue.flush();</span><br><span class="line">        floatValue.flush();</span><br><span class="line">        classValue.flush();</span><br><span class="line">        doubleValue.flush();</span><br><span class="line">        longValue.flush();</span><br><span class="line">        changedTime = System.currentTimeMillis();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，才是真正的将<code>DynamicProperty</code>值更新了，<code>DynamicLongProperty</code>在更新之后获取数据时，会使用新值。  </p><p>接下来我们来看回调，<code>DynamicProperty</code>的notifyCallbacks方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void notifyCallbacks() &#123;</span><br><span class="line">    //遍历所有的callbacks，执行run</span><br><span class="line">    for (Runnable r : callbacks) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;Error in DynamicProperty callback&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里callbacks是<code>DynamicProperty</code>的属性，在给动态配置添加回调函数时，直接添加到<code>DynamicProperty.callbacks</code>属性中，来看<code>PropertyWrapper</code>类的addCallback犯法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addCallback(Runnable callback) &#123;</span><br><span class="line">        if (callback != null) &#123;</span><br><span class="line">            //这里的prop就是DynamicProperty</span><br><span class="line">            prop.addCallback(callback);</span><br><span class="line">            callbackList.add(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里，动态更新和回调就分析完了。  </p><p>有点复杂，我们再捋一遍：</p><ol><li><code>DynamicURLConfiguration</code>中的线程间隔一段时间从url中拉取配置</li><li>拉取配置后调用<code>AbstractPollingScheduler</code>类的populateProperties方法更新配置</li><li>populateProperties方法中调用属性<code>DynamicPropertyUpdater propertyUpdater</code>的addOrChangeProperty方法</li><li><code>DynamicPropertyUpdater</code>的方法addOrChangeProperty会进行新老配置型对比，调用<code>DynamicURLConfiguration</code>的setProperty方法修改变更项</li><li><code>DynamicURLConfiguration</code>的setProperty方法先修改本身存放的配置项，然后触发事件<code>fireEvent</code></li><li><code>DynamicURLConfiguration</code>中的监听器是<code>ConcurrentCompositeConfiguration</code>的属性<code>ConfigurationListener eventPropagater</code>,<code>ConcurrentCompositeConfiguration</code>每次增加配置源是会给每个源添加eventPropagater监听器</li><li><code>DynamicURLConfiguration</code>的fireEvent会通过eventPropagater触发<code>ConcurrentCompositeConfiguration</code>的fireEvent</li><li><code>ConcurrentCompositeConfiguration</code>的监听器包含一个<code>ExpandedConfigurationListenerAdapter</code>的适配器，包含一个<code>PropertyListener</code>的属性，将事件转到<code>PropertyListener</code>中</li><li><code>PropertyListener</code>的实现类是<code>DynamicProperty</code>的内部类<code>DynamicPropertyListener</code>，里面会调用<code>DynamicProperty</code>的静态方法<code>updateProperty</code></li><li><code>DynamicProperty</code>的<code>updateProperty</code>方法先从<code>ALL_PROPS</code>中获取配置<code>DynamicProperty</code>，更新配置项，然后通知所有的回调。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;archaius介绍&quot;&gt;&lt;a href=&quot;#archaius介绍&quot; class=&quot;headerlink&quot; title=&quot;archaius介绍&quot;&gt;&lt;/a&gt;archaius介绍&lt;/h1&gt;&lt;p&gt;archaius是Netflix公司开源项目之一，基于java的配置管理类库，主要用于多配置存储的动态获取。主要功能是对apache common configuration类库的扩展。在云平台开发中可以将其用作分布式配置管理依赖构件。同时，它有如下一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态获取属性&lt;/li&gt;
&lt;li&gt;高效和线程安全的配置操作&lt;/li&gt;
&lt;li&gt;配置改变时提供回调机制&lt;/li&gt;
&lt;li&gt;可以通过jmx操作配置&lt;/li&gt;
&lt;li&gt;复合配置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="spring" scheme="https://github.com/along101/categories/spring/"/>
    
    
      <category term="netflix" scheme="https://github.com/along101/tags/netflix/"/>
    
      <category term="archaius" scheme="https://github.com/along101/tags/archaius/"/>
    
      <category term="config" scheme="https://github.com/along101/tags/config/"/>
    
  </entry>
  
</feed>
